// Generated by dts-bundle v0.7.3

declare module 'voximplant-websdk' {
    import { Client } from "voximplant-websdk/Client";
    import '../node_modules/webrtc-adapter/';
    import Messaging from "voximplant-websdk/Messenger/index";
    export { Events } from "voximplant-websdk/Events";
    export { CallEvents } from "voximplant-websdk/Call/CallEvents";
    export { Endpoint } from "voximplant-websdk/Call/EndPoints/Endpoint";
    export { EndpointEvents } from "voximplant-websdk/Call/EndPoints/EndpointEvents";
    export { Messaging } from "voximplant-websdk/Messenger";
    export { OperatorACDStatuses, LoginTokens, VideoFlags, LogRecord, CallstatsIoParams } from "voximplant-websdk/Structures";
    export { LogCategory, LogLevel, ClientState } from "voximplant-websdk/Logger";
    export * from "voximplant-websdk/Hardware/index";
    /**
        * Get a [Client] instance to use platform functions
        * @example
        *  var vox = VoxImplant.getInstance();
        *  vox.init({micRequired: true});
        *  vox.addEventListener(VoxImplant.Events.SDKReady, handleSDKReady);
        * @returns {Client}
        */
    export function getInstance(): Client;
    /**
        * VoxImplant Web SDK lib version
        */
    export const version: string;
    /**
        * Get instance of messaging subsystem
        * @returns {Messenger}
        *
        */
    export function getMessenger(): Messaging.Messenger;
}

declare module 'voximplant-websdk/Client' {
    import { Call } from 'voximplant-websdk/Call/Call';
    import { AudioOutputInfo, AudioSourceInfo, CallSettings, Config, LoginOptions, LogRecord, OperatorACDStatuses, VideoFlags, VideoSettings, VideoSourceInfo } from 'voximplant-websdk/Structures';
    import { Events } from 'voximplant-websdk/Events';
    import { VoxSignalingHandler } from 'voximplant-websdk/Signaling/VoxSignalingHandler';
    import { ClientState, LogCategory, LogLevel } from 'voximplant-websdk/Logger';
    import { EventTarget } from 'voximplant-websdk/EventTarget';
    import { ZingayaAPI } from 'voximplant-websdk/Legacy/ZingayaAPI';
    import { EventHandlers } from 'voximplant-websdk/EventHandlers';
    import { MediaRenderer } from 'voximplant-websdk/Media/MediaRenderer';
    import AuthTokenResult = EventHandlers.AuthTokenResult;
    /**
        * The Client class is used to control platform functions. Can't be instantiated directly (singleton), so use the [getInstance] method to get the class instance.
        *
        *
        * Example:
        * ``` js
        * // Getting an instance
        * var vox = VoxImplant.getInstance();
        * ```
    
        */
    export class Client extends EventTarget<Events> implements VoxSignalingHandler {
            /**
                * @hidden
                */
            videoSupport: boolean;
            /**
                * @hidden
                */
            localVideoContainerId: string;
            /**
                * @hidden
                */
            remoteVideoContainerId: string;
            /**
                * @hidden
                */
            _defaultSinkId: string;
            /**
                * @hidden
                */
            constructor();
            /**
                * Return VoxImplant Web SDK version
                * @function
                * @hidden
                */
            readonly version: string;
            /**
                * @hidden
                */
            static getInstance(): Client;
            /**
                * Plays progress tone according to specified country in config.progressToneCountry
                * @hidden
                */
            playProgressTone(check?: boolean): void;
            /**
                * Stop progress tone
                * @hidden
                */
            stopProgressTone(): void;
            /**
                * @hidden
                */
            onIncomingCall(id: any, callerid: any, displayName: any, headers: any, hasVideo: any): void;
            /**
                * Initialize SDK. The [Events.SDKReady] event will be dispatched after successful SDK initialization. SDK can't be used until it's initialized
                * @param {VoxImplant.Config} [config] Client configuration options
                */
            init(config: Config): Promise<EventHandlers.SDKReady | string>;
            /**
                * Create call
                * @name VoxImplant.Client.call
                * @param {String} num The number to call. For SIP compatibility reasons it should be a non-empty string even if the number itself is not used by a Voximplant cloud scenario.
                * @param {Boolean} useVideo Tells if video should be supported for the call. It's false by default.
                * @param {String} customData Custom string associated with the call session. It can be passed to the cloud to be obtained from the [CallAlerting](https://voximplant.com/docs/references/voxengine/appevents#callalerting) event or [Call History](https://voximplant.com/docs/references/httpapi/managing_history#getcallhistory) using HTTP API. Maximum size is 200 bytes. Use the [Call.sendMessage] method to pass a string over the limit; in order to pass a large data use [media_session_access_url](https://voximplant.com/docs/references/httpapi/managing_scenarios#startscenarios) on your backend.
                * @param {Object} extraHeaders Optional custom parameters (SIP headers) that should be passed with call (INVITE) message. Parameter names must start with "X-" to be processed by application. IMPORTANT: Headers size limit is 200 bytes.
        
                * @returns {VoxImplant.Call}
                */
            call(num: string | CallSettings, useVideo?: boolean | VideoFlags, customData?: string, extraHeaders?: {
                    [id: string]: string;
            }): Call;
            /**
                * Create call to a dedicated conference without proxy session. For details see <a href="https://medium.com/voximplant/video-conferencing-guide-for-voximplant-developers-8b1096e30129"> the video conferencing guide</a>
                * @param {String} num The number to call. For SIP compatibility reasons it should be a non-empty string even if the number itself is not used by a Voximplant cloud scenario.
                * @param {Boolean} useVideo Tells if video should be supported for the call. It's false by default.
                * @param {String} customData Custom string associated with the call session. It can be passed to the cloud to be obtained from the [CallAlerting](https://voximplant.com/docs/references/voxengine/appevents#callalerting) event or [Call History](https://voximplant.com/docs/references/httpapi/managing_history#getcallhistory) using HTTP API. Maximum size is 200 bytes. Use the [Call.sendMessage] method to pass a string over the limit; in order to pass a large data use [media_session_access_url](https://voximplant.com/docs/references/httpapi/managing_scenarios#startscenarios) on your backend.
                * @param {Object} extraHeaders Optional custom parameters (SIP headers) that should be passed with call (INVITE) message. Parameter names must start with "X-" to be processed by application. IMPORTANT: Headers size limit is 200 bytes.
                * @returns {Call}
                */
            callConference(num: string | CallSettings, useVideo?: boolean | VideoFlags, customData?: string, extraHeaders?: {
                    [id: string]: string;
            }): Call;
            /**
                * Get current config
                */
            config(): Config;
            /**
                * Connect to VoxImplant Cloud
                */
            connect(connectivityCheck?: boolean): Promise<Object>;
            /**
                * Connect to specific VoxImplant Cloud host
                * @name VoxImplant.Client.connectTo
                * @hidden
                */
            connectTo(host: string, omitMicDetection?: boolean, connectivityCheck?: boolean): void;
            /**
                * Disconnect from VoxImplant Cloud
                */
            disconnect(): void;
            /**
                * Set ACD status
                * @param {OperatorACDStatuses} Automatic call distributor status
                */
            setOperatorACDStatus(status: OperatorACDStatuses): Promise<OperatorACDStatuses>;
            /**
                * Return current ACD status of the operator.
                * @returns {Promise<OperatorACDStatuses>}
                */
            getOperatorACDStatus(): Promise<OperatorACDStatuses>;
            /**
                * Log in to an application. The method triggers the [Events.AuthResult] event.
                * @param {String} username Fully-qualified username that includes Voximplant user, application and account names. The format is: "username@appname.accname.voximplant.com".
                * @param {String} password
                * @param {VoxImplant.LoginOptions} [options]
                */
            login(username: string, password: string, options?: LoginOptions): Promise<EventHandlers.AuthResult>;
            /**
                * Log in to an application using the 'code' auth method. The method triggers the [Events.AuthResult] event.
                *
                * Please, read <a href="http://voximplant.com/docs/quickstart/24/automated-login/">howto page</a>
                * @param {String} username Fully-qualified username that includes Voximplant user, application and account names. The format is: "username@appname.accname.voximplant.com".
                * @param {String} code
                * @param {VoxImplant.LoginOptions} [options]
                * @hidden
                */
            loginWithCode(username: string, code: string, options?: LoginOptions): Promise<Object>;
            /**
                * Log in to an application using an accessToken. The method triggers the [Events.AuthResult] event.
                * @param {String} username Fully-qualified username that includes Voximplant user, application and account names. The format is: "username@appname.accname.voximplant.com".
                * @param {String} token
                * @param {VoxImplant.LoginOptions} [options]
                */
            loginWithToken(username: string, token: string, options?: LoginOptions): Promise<Object>;
            /**
                * Refresh expired access token
                * @param {String} username Fully-qualified username that includes Voximplant user, application and account names. The format is: "username@appname.accname.voximplant.com".
                * @param {String} refreshToken
                * @param {String} deviceToken A unique token for the current device
                */
            tokenRefresh(username: string, refreshToken: string, deviceToken?: string): Promise<AuthTokenResult>;
            /**
                * Request a key for the 'onetimekey' auth method.
                * Server will send the key in the [Events.AuthResult] event with the code 302.
                *
                * Please, read the <a href="http://voximplant.com/docs/quickstart/24/automated-login/">how-to page</a>.
                * @param {String} username
                */
            requestOneTimeLoginKey(username: string): Promise<Object>;
            /**
                * Log in to an application using the 'onetimekey' auth method.
                * Hash should be calculated with the key from the triggered [Events.AuthResult] event.
                *
                * Please, read the <a href="http://voximplant.com/docs/quickstart/24/automated-login/">how-to page</a>.
                * @param {String} username
                * @param {String} hash
                * @param {VoxImplant.LoginOptions} [options]
                */
            loginWithOneTimeKey(username: string, hash: string, options?: LoginOptions): Promise<Object>;
            /**
                * Check if connected to VoxImplant Cloud
                * @deprecated
                * See [[Client.getClientState]]
                */
            connected(): boolean;
            /**
                * Show/hide local video. *IMPORTANT*: Safari browser for iOS requires a user interface for playing video during a call. It should be interactive element like an HTML "button" with "onclick" handler that calls "play" method on the "video" HTML element.
                * @param {Boolean} [flag=true] Show/hide - true/false
                * @param {Boolean} [mirror=false] Mirror local video
                * @param {Boolean} [detachCamera=false] Detach camera on hide local video
                */
            showLocalVideo(flag?: boolean, mirror?: boolean, detachCamera?: boolean): Promise<MediaRenderer | void>;
            /**
                * Set local video position
                * @param {Number} x Horizontal position (px)
                * @param {Number} y Vertical position (px)
                * @function
                * @hidden
                * @deprecated
                * @name VoxImplant.Client.setLocalVideoPosition
                */
            setLocalVideoPosition(x: number, y: number): void;
            /**
                * Set local video size
                * @param {Number} width Width in pixels
                * @param {Number} height Height in pixels
                * @function
                * @hidden
                * @deprecated
                * @name VoxImplant.Client.setLocalVideoSize
                */
            setLocalVideoSize(width: number, height: number): void;
            /**
                * Set video settings globally. This settings will be used for the next call.
                * @param {VoxImplant.VideoSettings|VoxImplant.FlashVideoSettings} settings Video settings
                * @param {Function} [successCallback] Success callback function has MediaStream object as its argument
                * @param {Function} [failedCallback] Failed callback function
                * @deprecated
                * @hidden
                */
            setVideoSettings(settings: VideoSettings, successCallback?: Function, failedCallback?: Function): void;
            /**
                * Set bandwidth limit for video calls. Currently supported by Chrome/Chromium. (WebRTC mode only). The limit will be applied for the next call.
                * @param {Number} bandwidth Bandwidth limit in kilobits per second (kbps)
                */
            setVideoBandwidth(bandwidth: number): void;
            /**
                * Play ToneScript using WebAudio API
                * @param {String} script Tonescript string
                * @param {Boolean} [loop=false] Loop playback if true
                */
            playToneScript(script: string, loop?: boolean): void;
            /**
                * Stop playing ToneScript using WebAudio API
                */
            stopPlayback(): void;
            /**
                * Change current global sound volume
                * @deprecated
                * @param {Number} level New sound volume value between 0 and 100
                * @function
                * @hidden
                */
            volume(level: number): number;
            /**
                * Get a list of all currently available audio sources / microphones
                * @deprecated
                * @hidden
                */
            audioSources(): AudioSourceInfo[];
            /**
                * Get a list of all currently available video sources / cameras
                * @deprecated
                * @hidden
                */
            videoSources(): VideoSourceInfo[];
            /**
                * Get a list of all currently available audio playback devices
                * @deprecated
                * @hidden
                */
            audioOutputs(): AudioOutputInfo[];
            /**
                * Use specified audio source, use [audioSources] to get the list of available audio sources
                * If SDK was init with micRequired: false, force attach microphone.
                * @param {String} id Id of the audio source
                * @param {Function} [successCallback] Called in WebRTC mode if audio source changed successfully
                * @param {Function} [failedCallback] Called in WebRTC mode if audio source couldn't changed successfully
                * @deprecated
                * @hidden
                */
            useAudioSource(id: string, successCallback?: Function, failedCallback?: Function): Promise<MediaStream>;
            /**
                * Use specified video source, use [videoSources] to get the list of available video sources
                * @param {String} id Id of the video source
                * @param {Function} [successCallback] Called if video source changed successfully, has MediaStream object as its argument
                * @param {Function} [failedCallback] Called if video source couldn't be changed successfully, has MediaStreamError object as its argument
                * @deprecated
                * @hidden
                */
            useVideoSource(id: string, successCallback?: Function, failedCallback?: Function): Promise<MediaStream>;
            /**
                * Use specified audio output for new calls, use [audioOutputs] to get the list of available audio output
                * @param {String} id Id of the audio source
                * @deprecated
                * @hidden
                */
            useAudioOutput(id: string): Promise<void>;
            /**
                * Enable microphone/camera if micRequired in [Config] was set to false.
                * @param {Function} successCallback Called if selected recording devices were attached successfully, has MediaStream object as its argument
                * @param {Function} failedCallback Called if selected recording devices couldn't be attached, has MediaStreamError object as its argument
                * @deprecated
                * @hidden
                */
            attachRecordingDevice(successCallback?: Function, failedCallback?: Function): Promise<MediaStreamTrack>;
            /**
                * Disable microphone/camera if micRequired in [Config] was set to false
                * @deprecated
                * @hidden
                */
            detachRecordingDevice(): void;
            /**
                * Set active call
                * @param {VoxImplant.Call} call VoxImplant call instance
                * @param {Boolean} [active=true] If true make call active, otherwise make call inactive
                * @deprecated
                * @hidden
                */
            setCallActive(call: Call, active?: boolean): Promise<EventHandlers.Updated>;
            /**
                * Start/stop sending local video to remote party/parties. *IMPORTANT*: Safari browser for iOS requires a user interface for playing video during a call. It should be interactive element like an HTML "button" with "onclick" handler that calls "play" method on the "video" HTML element.
                * @param {Boolean} [flag=true] Start/stop - true/false
                * @deprecated
                * @hidden
                */
            sendVideo(flag?: boolean): void;
            /**
                * Check if WebRTC support is available
                * @returns {Boolean}
                */
            isRTCsupported(): boolean;
            /**
                * Transfer call, depending on the result [CallEvents.TransferComplete] or [CallEvents.TransferFailed] event will be dispatched.
                * @param {VoxImplant.Call} call1 Call which will be transferred
                * @param {VoxImplant.Call} call2 Call where call1 will be transferred
                */
            transferCall(call1: Call, call2: Call): void;
            /**
                * Set log levels for specified log categories
                * @param {LogCategory} category Log category
                * @param {LogLevel} level Log level
                * @hidden
                */
            setLogLevel(category: LogCategory, level: LogLevel): void;
            /**
                * @hidden
                */
            onSignalingConnected(): void;
            /**
                * @hidden
                */
            onSignalingClosed(): void;
            /**
                * @hidden
                */
            onSignalingConnectionFailed(reason: any): void;
            /**
                * @hidden
                */
            onMediaConnectionFailed(): void;
            /**
                * Not documented function for backward compatibility
                * @hidden
                * @param string call_id Call ID
                * @returns {Call}
                */
            getCall(call_id: string): Call;
            /**
                * Not documented function for backward compatibility
                * Remove call from calls array
                * @param string call_id Call id
                * @hidden
                */
            removeCall(call_id: string): void;
            /**
                * Returns promise that is resolved with a boolean flag. The boolean flag
                * is set to 'true' if screen sharing is supported.
                * Promise is rejected in case of an internal error.
                */
            screenSharingSupported(): Promise<boolean>;
            /**
                * Register handler for specified event
                * @param event Event class (i.e. [Events.SDKReady]). See [Events]
                * @param handler Handler function. A single parameter is passed - object with event information
                * @deprecated
                * @hidden
                */
            addEventListener(event: Events, handler: Function): void;
            /**
                * Remove handler for specified event
                * @param {Function} event Event class (i.e. [Events.SDKReady]). See [Events]
                * @param {Function} [handler] Handler function, if not specified all event handlers will be removed
                * @function
                * @deprecated
                * @hidden
                */
            removeEventListener(event: Events, handler?: Function): void;
            /**
                * Register a handler for the specified event. The method is a shorter equivalent for *addEventListener*. One event can have more than one handler; handlers are executed in order of registration.
                * Use the [Client.off] method to delete a handler.
                * @param {Function} event Event class (i.e. [Events.SDKReady]). See [Events]
                * @param {Function} handler Handler function. A single parameter is passed - object with event information
                * @function
                */
            on(event: Events, handler: Function): void;
            /**
                * Remove a handler for the specified event. The method is a shorter equivalent for *removeEventListener*. If a number of events has the same function as a handler, the method can be called multiple times with the same handler argument.
                * @param {Function} event Event class (i.e. [Events.SDKReady]). See [Events]
                * @param {Function} [handler] Handler function, if not specified all event handlers will be removed
                * @function
                */
            off(event: Events, handler?: Function): void;
            /**
                * @hidden
                * @param val
                */
            sslset(val: boolean): void;
            /**
                * @hidden
                * @returns {Array<string>}
                */
            sslget(): Array<string>;
            /**
                * @hidden
                */
            getZingayaAPI(): ZingayaAPI;
            /**
                * Register for push notifications. Application will receive push notifications from VoxImplant Server after first log in.
                * @hidden
                * @param token FCM registration token that can be retrieved by calling firebase.messaging().getToken() inside a service worker
                * @returns {Promise<void>}
                */
            registerForPushNotificatuons(token: string): Promise<void>;
            /**
                * Unregister from push notifications. Application will no longer receive push notifications from VoxImplant server.
                * @hidden
                * @param token FCM registration token that was used to register for push notifications
                * @returns {Promise<void>}
                */
            unregisterForPushNotificatuons(token: string): Promise<void>;
            /**
                * Handle incoming push notification
                * @hidden
                * @param message  Incoming push notification that comes from the firebase.messaging().setBackgroundMessageHandler callback inside a service worker
                * @returns {Promise<void>}
                */
            handlePushNotification(message: any): Promise<void>;
            /**
                * Generate a new GUID identifier. Unique each time.
                * @hidden
                */
            getGUID(): string;
            /**
                * @hidden
                * @param {boolean} flag
                */
            setSilentLogging(flag: boolean): void;
            /**
                * Set the state of the silent logging inside SDK (it is disabled by default). When it is enabled, the WebSDK will save all log messages into the log until you disable it.
                *
                * Note that enabling of the silent logging automatically clears all existed log records before the start.
                *
                * You can get current log by the [getSilentLog] function and clean it by the [clearSilentLog] function.
                * @param {boolean} flag
                */
            enableSilentLogging(flag: boolean): void;
            /**
                * Clear the log journal and free some memory.
                */
            clearSilentLog(): void;
            /**
                * Get records from the log journal.
                * @returns {Array<string>}
                */
            getSilentLog(): Array<string>;
            /**
                * Set outer logging callback.
                *
                * The method allows integrating logging pipeline of the WebSDK into your own logger i.e. the method call sends all events to your function.
                * *IMPORTANT:* the callback strictly ignores Loglevel settings of the WebSDK.
                *
                * @param {{(record: LogRecord): void}} callback
                */
            setLoggerCallback(callback: {
                    (record: LogRecord): void;
            }): void;
            /**
                * Get current client state
                * @return {ClientState}
                */
            getClientState(): ClientState;
            /**
                * @hidden
                * @deprecated
                * @returns {any}
                */
            setSwfColor(): any;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
            /**
                * @hidden
                * @param {number} as
                * @param {number} tias
                */
            setXAS(as: number, tias: number): void;
            /**
                * @hidden
                */
            removeCC(flag: boolean): void;
    }
}

declare module 'voximplant-websdk/Messenger/index' {
    import * as ImplementME from 'voximplant-websdk/Messenger/MessengerEventsCallbacks/index';
    import * as Implement from 'voximplant-websdk/Messenger/src';
    /**
        * Messaging allows exchanging instant messages between 2 or more participants.
        * Messaging supports text and metadata. The conversation doesn't bind or depend on the audio/video calls, but there is a possibility to integrate messaging in audio/video calls.
        *
        * FEATURES:
        * 1. messaging is the separate part of WEB SDK, but it uses the [Client.login], [Client.loginWithOneTimeKey] and [Client.loginWithToken] methods - in brief, if a user was already logged in he can use messaging functionality.
        * 1. messaging doesn't use backend JS scenario at all
        * See the minimum example to create messaging and to be able start a conversation:
        * @example
        * const voxSDK = VoxImplant.getInstance();
        * voxSDK.init({micRequired:false})
        *   .then(()=>voxSDK.connect())
        *   .then(()=>sdk.login('foo@bar.baz.voximplant.com', 'secretpass'))
        *   .then((e)=>{
        *     if(!e.result)
        *       throw e.message;
        *     console.log('[Voximplant] Ready, connected and logged in.');
        *     return VoxImplant.getMessenger();
        *   })
        *   .then((messaging)=>{
        *     messaging.on(VoxImplant.Messaging.MessengerEvents.CreateConversation,onCreateConversation);
        *     messaging.createConversation([]);
        *   })
        *   .catch(e=>console.error('[Voximplant] Oops! Something went wrong',e));
        *
        * function onCreateConversation(e){
        *   console.log(`[Voximplant] New conversation here! ID:${e.conversation.uuid}`);
        *   e.conversation.sendMessage('Hello world!');
        * }
        *
        * function onSendMessage(e){
        *   console.log(`[Voximplant] Message from ${e.message.sender}: ${e.message.text}`)
        * }
        *
        */
    export module Messaging {
            /**
                * Messaging supports these events. See the details within a particular event.
                */
            module EventHandlers {
                    /**
                        * Interface that represents messenger events related to conversation such as create, edit, remove and others.
                        */
                    interface ConversationEvent extends ImplementME.ConversationEvent {
                    }
                    /**
                        * Interface that represents messenger events such as typing, isRead, isDelivered.
                        */
                    interface ConversationServiceEvent extends ImplementME.ConversationServiceEvent {
                    }
                    /**
                        * Interface that represents error messenger events.
                        */
                    interface ErrorEvent extends ImplementME.ErrorEvent {
                    }
                    /**
                        * Interface that represents messenger events related to messages.
                        */
                    interface MessageEvent extends ImplementME.MessageEvent {
                    }
                    /**
                        * Interface that represents all messenger events provided via [Messenger.on]
                        */
                    interface MessengerEvent extends ImplementME.MessengerEvent {
                    }
                    /**
                        * commented NOV-26-2018 by npushkarskiy because retransmitEvents are obsolete
                        * Event is triggered after [Conversation.retransmitEvents] method is called on some conversation for this SDK instance.
                     
                    export interface RetransmitEvent extends ImplementME.RetransmitEvent{};*/
                    /**
                        * Event is triggered after the user presence state has changed.
                        */
                    interface StatusEvent extends ImplementME.StatusEvent {
                    }
                    /**
                        * Event is triggered by the [Conversation.retransmitEvents] and [Messenger.unsubscribe] methods.
                        */
                    interface SubscriptionEvent extends ImplementME.SubscriptionEvent {
                    }
                    /**
                        * Event is triggered after the user presence state has changed.
                        */
                    interface UserEvent extends ImplementME.UserEvent {
                    }
            }
            /**
                * @hidden
                * @deprecated
                */
            module MessengerEventsCallbacks {
                    /**
                        * @hidden
                        */
                    interface ConversationEvent extends ImplementME.ConversationEvent {
                    }
                    /**
                        * @hidden
                        */
                    interface ConversationServiceEvent extends ImplementME.ConversationServiceEvent {
                    }
                    /**
                        * @hidden
                        */
                    interface ErrorEvent extends ImplementME.ErrorEvent {
                    }
                    /**
                        * @hidden
                        */
                    interface MessageEvent extends ImplementME.MessageEvent {
                    }
                    /**
                        * @hidden
                        */
                    interface MessengerEvent extends ImplementME.MessengerEvent {
                    }
                    /**
                        * @hidden
                        */
                    interface RetransmitEvent extends ImplementME.RetransmitEvent {
                    }
                    /**
                        * @hidden
                        */
                    interface StatusEvent extends ImplementME.StatusEvent {
                    }
                    /**
                        * @hidden
                        */
                    interface SubscriptionEvent extends ImplementME.SubscriptionEvent {
                    }
                    /**
                        * @hidden
                        */
                    interface UserEvent extends ImplementME.UserEvent {
                    }
            }
            /**
                * Conversation instance. Created by the [Messenger.createConversation] method. Used to send messages, add or remove users, change moderators list etc.
                */
            class Conversation extends Implement.Conversation {
            }
            /**
                * Describes single message. Received via the [MessengerEvents.SendMessage] or [MessengerEvents.EditMessage] events and used to serialize or edit the message.
                */
            class Message extends Implement.Message {
            }
            /**
                * Messenger class is used to control messaging functions. Can't be instantiated directly (singleton), please use [getMessenger] to get the class instance.
                */
            class Messenger extends Implement.Messenger {
            }
            /**
                * User description returned by the [Messenger.getUser] method.
                */
            interface User extends Implement.User {
            }
            /**
                * User description for the conversation
                */
            interface ConversationParticipant extends Implement.ConversationParticipant {
            }
            /**
                * User status information available in the [MessengerEvents.SetStatus] event.
                */
            interface UserStatus extends Implement.UserStatus {
            }
            /**
                * Serialized conversation information that can be stored into some storage (like IndexedDB) and later restored via [Messenger.createConversationFromCache]
                */
            interface SerializedConversation extends Implement.SerializedConversation {
            }
            /**
                * Serialized message information that can be stored into some storage (like IndexedDB) and later restored via [Messenger.createMessageFromCache]
                */
            interface SerializedMessage extends Implement.SerializedMessage {
            }
            interface RetransmittedEvent extends Implement.RetransmittedEvent {
            }
            enum MessengerEvents {
                    /**
                        * New conversation created.
                        * You receive this event when anybody created a new conversation with the current user in participant array. Also this event dispatch on conversation creator.
                        */
                    CreateConversation = "CreateConversation",
                    /**
                        * Conversation properties were modified.
                        */
                    EditConversation = "EditConversation",
                    /**
                        * The conversation was removed.
                        */
                    RemoveConversation = "RemoveConversation",
                    /**
                        * Conversation description is received. Triggered in response to the 'getConversation'.
                        */
                    GetConversation = "GetConversation",
                    /**
                        * Event is triggered when a new message is received as a result of the [Conversation.sendMessage] method call.
                        */
                    SendMessage = "SendMessage",
                    /**
                        * Message was edited.
                        */
                    EditMessage = "EditMessage",
                    /**
                        * Message was removed.
                        */
                    RemoveMessage = "RemoveMessage",
                    /**
                        * Information that some user is typing something is received. Triggered in response to the 'typing' called by any user.
                        */
                    Typing = "Typing",
                    /**
                        * Dispatch when [Messenger.editUser] successful done into cloud. Triggered only for users specified in the 'subscribe' method call.
                        */
                    EditUser = "EditUser",
                    /**
                        * Return user, requested in [Messenger.getUser] function
                        */
                    GetUser = "GetUser",
                    /**
                        * Event is triggered in case of an error while creating a conversation. See the details in the [MessengerEventsCallbacks.ErrorEvent] interface.
                        */
                    Error = "Error",
                    /**
                        * Event is triggered after [Conversation.retransmitEvents] method is called on some conversation for this SDK instance.
                        */
                    RetransmitEvents = "RetransmitEvents",
                    /**
                        *  Event is triggered after another device with same logged in user called the [Conversation.markAsRead] method.
                        */
                    Read = "Read",
                    /**
                        * Event is triggered after another device with same logged in user called the [Conversation.markAsDelivered] method.
                        */
                    Delivered = "Delivered",
                    /**
                        * Event is triggered after the [Messenger.subscribe] method is called.
                        */
                    Subscribe = "Subscribe",
                    /**
                        * Event is triggered after the [Messenger.unsubscribe] method is called.
                        */
                    Unsubscribe = "Unsubscribe",
                    /**
                        * Event is triggered after the user presence state has changed.
                        */
                    SetStatus = "SetStatus"
            }
            /**
                * Available methods to manipulate the messaging flow. Note if the action triggers any of [MessengerEvents], the action's name will be set as a value of [ConversationEvent.messengerAction].
                */
            enum MessengerAction {
                    createConversation,
                    editConversation,
                    removeConversation,
                    joinConversation,
                    leaveConversation,
                    getConversation,
                    getConversations,
                    sendMessage,
                    editMessage,
                    removeMessage,
                    typingMessage,
                    editUser,
                    getUser,
                    getUsers,
                    retransmitEvents,
                    isRead,
                    isDelivered,
                    addParticipants,
                    editParticipants,
                    removeParticipants,
                    addModerators,
                    removeModerators,
                    subscribe,
                    unsubscribe,
                    setStatus
            }
            /**
                *
                */
            enum MessengerError {
                    /**
                        * Wrong transport message structure
                        */
                    Error_1,
                    /**
                        * Unknown event name
                        */
                    Error_2,
                    /**
                        * User not auth
                        */
                    Error_3,
                    /**
                        * Wrong message structure
                        */
                    Error_4,
                    /**
                        * Conversation not found or user not in participant list
                        */
                    Error_5,
                    /**
                        * Conversation not found or user can't moderate conversation
                        */
                    Error_6,
                    /**
                        * Conversation already exists
                        */
                    Error_7,
                    /**
                        * Conversation does not exist
                        */
                    Error_8,
                    /**
                        * Message already exists
                        */
                    Error_9,
                    /**
                        * Message does not exist
                        */
                    Error_10,
                    /**
                        * Message was deleted
                        */
                    Error_11,
                    /**
                        * ACL error
                        */
                    Error_12,
                    /**
                        * User already in participant list
                        */
                    Error_13,
                    /**
                        * No rights to edit user
                        */
                    Error_14,
                    /**
                        * Public join is not available in this conversation
                        */
                    Error_15,
                    /**
                        * Conversation was deleted
                        */
                    Error_16,
                    /**
                        * Conversation is distinct
                        */
                    Error_17,
                    /**
                        * User validation Error
                        */
                    Error_18,
                    /**
                        * Lists mismatch
                        */
                    Error_19,
                    /**
                        * Range larger then allowed by service
                        */
                    Error_21,
                    /**
                        * Number of requested objects is larger then allowed by service
                        */
                    Error_22,
                    /**
                        * Message size so large
                        */
                    Error_23,
                    /**
                        * Seq is too big
                        */
                    Error_24,
                    /**
                        * IM service not available
                        */
                    Error_30,
                    /**
                        * Internal error
                        */
                    Error_500,
                    /**
                        * Oops! Something went wrong
                        */
                    Error_777
            }
    }
    export default Messaging;
}

declare module 'voximplant-websdk/Events' {
    /**
        * The events that are triggered by [Client] instance. See the [getInstance] method.
        *
        *
        * Example:
        * ``` js
        * var vox = VoxImplant.getInstance();
        * vox.init({micRequired: true});
        * vox.addEventListener(VoxImplant.Events.SDKReady, function() {
        *   vox.connect();
        * });
        * ```
        */
    export enum Events {
            /**
                *    The event is triggered after SDK was successfully initialized after the [Client.init] function call
                *
                *    Handler function receives [EventHandlers.SDKReady] object as an argument.
                */
            SDKReady,
            /**
                *    The event is triggered after connection to VoxImplant Cloud was established successfully.
                *    See [Client.connect] function
                *
                *    Handler function receives no arguments.
                */
            ConnectionEstablished,
            /**
                *    The event is triggered if a connection to the VoxImplant cloud couldn't be established.
                *    See [Client.connect] function
                *
                *    Handler function receives the [EventHandlers.ConnectionFailed] object as an argument.
                */
            ConnectionFailed,
            /**
                * The event is triggered if a connection to VoxImplant Cloud was closed because of network problems.
                *
                *    See the [Client.connect] function
                *
                *    Handler function receives no arguments.
                */
            ConnectionClosed,
            /**
                * The event is triggered after the [Client.login], [Client.loginWithOneTimeKey] and [Client.loginWithCode] methods call.
                *
                * Handler function receives [EventHandlers.AuthResult] object as an argument.
                */
            AuthResult,
            /**
                *   The event is triggered after the [LoginTokens.refreshToken] call
                *   Handler function receives the the [EventHandlers.AuthTokenResult] object as an argument.
                */
            RefreshTokenResult,
            /**
                *    The event is triggered after sound playback was stopped.
                *
                *    See [Client.playToneScript]
                *    and [Client.stopPlayback] functions
                *
                *    Handler function receives no arguments.
                */
            PlaybackFinished,
            /**
                * @hidden
                * @deprecated
                */
            MicAccessResult,
            /**
                *    The event is triggered when there is a new incoming call to current user
                *
                *    Handler function receives [EventHandlers.IncomingCall] object as an argument.
                */
            IncomingCall,
            /**
                * The event is triggered when audio and video sources information was updated.
                *    See the [Client.audioSources] and [Client.videoSources] for details
                * @hidden
                * @deprecated
                */
            SourcesInfoUpdated,
            /**
                * @hidden
                * @deprecated
                */
            NetStatsReceived,
            /**
                * @hidden
                */
            SIPRegistrationSuccessful,
            /**
                * @hidden
                */
            SIPRegistrationFailed,
            /**
                * The event is triggered when ACD status of current user changed from SDK or from inside the ACD service.
                */
            ACDStatusUpdated
    }
}

declare module 'voximplant-websdk/Call/CallEvents' {
    /**
        * The events that are triggered by [Call] instance.
        *
        * Use [Call.on] to subscribe on
        * any of these events.
        *
        *
        * Example:
        * ``` js
        * var currentCall = vox.call("exampleUser");
        * currentCall.on(VoxImplant.CallEvents.Connected,onConnected);
        * currentCall.on(VoxImplant.CallEvents.Disconnected,onDisconnected);
        * currentCall.on(VoxImplant.CallEvents.Failed,onFailed);
        * currentCall.on(VoxImplant.CallEvents.ICETimeout,onICETimeout)
        * ```
        */
    export enum CallEvents {
            /**
                * Event is triggered when a reliable connection is established for the call. Depending on network conditions there can be a 2-3 seconds delay between first audio data and this event.
                * Handler function receives [EventHandlers.CallEventWithHeaders] object as an argument.
                */
            Connected,
            /**
                *  Event is triggered when a call was disconnected
                *  Handler function receives the [EventHandlers.Disconnected] object as an argument.
                */
            Disconnected,
            /**
                *  Event is triggered due to a call failure
                *
                *  Most frequent status codes:
                *
                * |Code|Description                      |
                * |----|---------------------------------|
                * |486 |Destination number is busy       |
                * |487 |Request terminated               |
                * |603 |Call was rejected                |
                * |404 |Invalid number                   |
                * |480 |Destination number is unavailable|
                * |402 |Insufficient funds               |
                *
                * Handler function receives the [EventHandlers.Failed] object as an argument.
                */
            Failed,
            /**
                *  Event is triggered when a progress tone playback starts.
                *  Handler function receives the [EventHandlers.CallEvent] object as an argument.
                */
            ProgressToneStart,
            /**
                *  Event is triggered when a progress tone playback stops.
                *  Handler function receives the [EventHandlers.CallEvent] object as an argument.
                */
            ProgressToneStop,
            /**
                *  Event is triggered when a text message is received.
                *  Handler function receives the [EventHandlers.MessageReceived] object as an argument.
                */
            MessageReceived,
            /**
                *  Event is triggered when the INFO message is received
                *  Handler function receives [EventHandlers.InfoReceived] object as an argument.
                */
            InfoReceived,
            /**
                *  Event is triggered when a call has been transferred successfully.
                *  Handler function receives the [EventHandlers.CallEvent] object as an argument.
                */
            TransferComplete,
            /**
                *  Event is triggered when a call transfer failed
                *  Handler function receives the [EventHandlers.CallEvent] object as an argument.
                */
            TransferFailed,
            /**
                *  Event is triggered when connection was not established due to a network connection problem between 2 peers
                *  Handler function receives [EventHandlers.CallEvent] object as an argument.
                */
            ICETimeout,
            RTCStatsReceived,
            /**
                * Event is triggered when a new HTMLMediaElement for the call's media playback has been created
                * Handler function receives [EventHandlers.MediaElementCreated] object as an argument.
                * @hidden
                * @deprecated
                */
            MediaElementCreated,
            /**
                * @hidden
                * @deprecated
                * @type {string}
                */
            MediaElementRemoved,
            /**
                *  Event is triggered when an ICE connection is complete
                *  Handler function receives [EventHandlers.CallEvent] object as an argument.
                */
            ICECompleted,
            /**
                * Event is triggered when a call was updated. For example, video was added/removed.
                * Handler function receives the [EventHandlers.Updated] object as an argument.
                */
            Updated,
            /**
                * Event is triggered when user receives the call update from another side. For example, a video was added/removed on the remote side.
                * Handler function receives [EventHandlers.CallEvent] object as an argument.
                * @hidden
                * @deprecated
                */
            PendingUpdate,
            /**
                * Event is triggered when multiple participants tried to update the same call simultaneously. For example, video added/removed on a local and remote side at the same time.
                * Handler function receives [EventHandlers.UpdateFailed] object as an argument.
                * @hidden
                * @deprecated
                */
            UpdateFailed,
            /**
                * Handler function receives [EventHandlers.LocalVideoStreamAdded] object as an argument.
                * @deprecated
                * @hidden
                */
            LocalVideoStreamAdded,
            /**
                * Event is triggered when a new Endpoint is created. [Endpoint] represents an another participant in your call or conference.
                */
            EndpointAdded
    }
}

declare module 'voximplant-websdk/Call/EndPoints/Endpoint' {
    import { EventTarget } from 'voximplant-websdk/EventTarget';
    import { EndpointEvents } from 'voximplant-websdk/Call/EndPoints/EndpointEvents';
    import { MediaRenderer } from 'voximplant-websdk/Media/MediaRenderer';
    import { EndpointInfoData } from 'voximplant-websdk/Call/EndpointListDescription';
    /**
        * Interface that represents any remote media unit in a call. Current endpoints can be retrieved via the [Call.getEndpoints] method.
        *
        * Endpoint can be :
        * <ol>
        * <li><a href="//voximplant.com/docs/references/appengine/Module_ASR.html">ASR</a></li>
        * <li><a href="//voximplant.com/docs/references/appengine/Module_Recorder.html">Recorder</a></li>
        * <li><a href="//voximplant.com/docs/references/appengine/Module_Player.html">Player</a></li>
        * <li> or another <a href="//voximplant.com/docs/references/appengine/Call.html">call</a> (e.g. which is joined to the conference)</li>
        * </ol>
        */
    export class Endpoint extends EventTarget<EndpointEvents> {
            isDefault: boolean;
            /**
                * Unique ID of current Endpoint
                */
            id: string;
            /**
                * The list of all [mediaRenderers].
                */
            mediaRenderers: MediaRenderer[];
            /**
                * Get <a href="https://tools.ietf.org/html/rfc3261##section-19.1.1" target="_blank">SIP URI</a> of the endpoint
                */
            sipUri: string;
            /**
                * Get user display name of the endpoint.
                */
            displayName: string;
            /**
                * Get user name of the endpoint.
                */
            userName: string;
            /**
                * @hidden
                */
            constructor(/**
                                     * @hidden
            /**
                * @hidden
                */
            place: number;
            /**
                * Set audio output device for current Endpoint. Now supported by Google Chrome only
                * @param {string} id
                */
            useAudioOutput(id: string): void;
            /**
                * @hidden
                */
            updateInfo(data: EndpointInfoData): void;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
            /**
                * Register a handler for the specified event. The method is a shorter equivalent for *addEventListener*. One event can have more than one handler; handlers are executed in order of registration.
                * Use the [Endpoint.off] method to delete a handler.
                */
            on(event: EndpointEvents, handler: Function): void;
            /**
                * Remove a handler for the specified event. The method is a shorter equivalent for *removeEventListener*. If a number of events has the same function as a handler, the method can be called multiple times with the same handler argument.
                */
            off(event: EndpointEvents, handler?: Function): void;
    }
}

declare module 'voximplant-websdk/Call/EndPoints/EndpointEvents' {
    /**
        * Events that are triggered when Endpoint is updated/edited, removed or started/stopped to receive stream from another Endpoint.
        */
    export enum EndpointEvents {
            /**
                * Event is triggered when an Endpoint is updated/edited. E.g. when
                * a display name is changed via the [setDisplayName](https://voximplant.com/docs/references/voxengine/conference/endpoint#setdisplayname) method.
                * [Voxengine](https://voximplant.com/docs/references/voxengine) example:
                * ```javascript
                * require(Modules.Conference);
                * // ...
                * endpoint.setDisplayName("Chuck Spadina");
                * ```
                * Web SDK example:
                * ```javascript
                * Endpoint.on(Voximplant.EndpointEvents.InfoUpdated, (e)=>{
                *   console.log(e.endpoint.displayName);
                *   // > Chuck Spadina
                * });
                * ```
                * Handler function receives the [EventHandlers.EndpointHandler] object as an argument.
                */
            InfoUpdated,
            /**
                * Event is triggered when an Endpoint is removed. E.g. when a participant left the conference or [player](https://voximplant.com/docs/references/voxengine/player) was removed.
                * Handler function receives the [EventHandlers.EndpointHandler] object as an argument.
                */
            Removed,
            /**
                * Event is triggered when an Endpoint started to receive an audio / video / screensharing stream from another Endpoint.
                * __IMPORTANT__: if you subscribe to the event, Web SDK will no longer render remote audio/video stream automatically; you have to render remote streams manually via the [MediaRenderer.render] method.
                * Handler function receives the [EventHandlers.EndpointMediaHandler] object as an argument.
                */
            RemoteMediaAdded,
            /**
                * Event is triggered when an Endpoint stopped to receive an audio / video / screensharing stream from another Endpoint.
                * Handler function receives the [EventHandlers.EndpointMediaHandler] object as an argument.
                */
            RemoteMediaRemoved,
            /**
                * @hidden
                */
            RTCStatsReceived
    }
}

declare module 'voximplant-websdk/Messenger' {
    import * as ImplementME from 'voximplant-websdk/Messenger/MessengerEventsCallbacks/index';
    import * as Implement from 'voximplant-websdk/Messenger/src';
    /**
        * Messaging allows exchanging instant messages between 2 or more participants.
        * Messaging supports text and metadata. The conversation doesn't bind or depend on the audio/video calls, but there is a possibility to integrate messaging in audio/video calls.
        *
        * FEATURES:
        * 1. messaging is the separate part of WEB SDK, but it uses the [Client.login], [Client.loginWithOneTimeKey] and [Client.loginWithToken] methods - in brief, if a user was already logged in he can use messaging functionality.
        * 1. messaging doesn't use backend JS scenario at all
        * See the minimum example to create messaging and to be able start a conversation:
        * @example
        * const voxSDK = VoxImplant.getInstance();
        * voxSDK.init({micRequired:false})
        *   .then(()=>voxSDK.connect())
        *   .then(()=>sdk.login('foo@bar.baz.voximplant.com', 'secretpass'))
        *   .then((e)=>{
        *     if(!e.result)
        *       throw e.message;
        *     console.log('[Voximplant] Ready, connected and logged in.');
        *     return VoxImplant.getMessenger();
        *   })
        *   .then((messaging)=>{
        *     messaging.on(VoxImplant.Messaging.MessengerEvents.CreateConversation,onCreateConversation);
        *     messaging.createConversation([]);
        *   })
        *   .catch(e=>console.error('[Voximplant] Oops! Something went wrong',e));
        *
        * function onCreateConversation(e){
        *   console.log(`[Voximplant] New conversation here! ID:${e.conversation.uuid}`);
        *   e.conversation.sendMessage('Hello world!');
        * }
        *
        * function onSendMessage(e){
        *   console.log(`[Voximplant] Message from ${e.message.sender}: ${e.message.text}`)
        * }
        *
        */
    export module Messaging {
            /**
                * Messaging supports these events. See the details within a particular event.
                */
            module EventHandlers {
                    /**
                        * Interface that represents messenger events related to conversation such as create, edit, remove and others.
                        */
                    interface ConversationEvent extends ImplementME.ConversationEvent {
                    }
                    /**
                        * Interface that represents messenger events such as typing, isRead, isDelivered.
                        */
                    interface ConversationServiceEvent extends ImplementME.ConversationServiceEvent {
                    }
                    /**
                        * Interface that represents error messenger events.
                        */
                    interface ErrorEvent extends ImplementME.ErrorEvent {
                    }
                    /**
                        * Interface that represents messenger events related to messages.
                        */
                    interface MessageEvent extends ImplementME.MessageEvent {
                    }
                    /**
                        * Interface that represents all messenger events provided via [Messenger.on]
                        */
                    interface MessengerEvent extends ImplementME.MessengerEvent {
                    }
                    /**
                        * commented NOV-26-2018 by npushkarskiy because retransmitEvents are obsolete
                        * Event is triggered after [Conversation.retransmitEvents] method is called on some conversation for this SDK instance.
                     
                    export interface RetransmitEvent extends ImplementME.RetransmitEvent{};*/
                    /**
                        * Event is triggered after the user presence state has changed.
                        */
                    interface StatusEvent extends ImplementME.StatusEvent {
                    }
                    /**
                        * Event is triggered by the [Conversation.retransmitEvents] and [Messenger.unsubscribe] methods.
                        */
                    interface SubscriptionEvent extends ImplementME.SubscriptionEvent {
                    }
                    /**
                        * Event is triggered after the user presence state has changed.
                        */
                    interface UserEvent extends ImplementME.UserEvent {
                    }
            }
            /**
                * @hidden
                * @deprecated
                */
            module MessengerEventsCallbacks {
                    /**
                        * @hidden
                        */
                    interface ConversationEvent extends ImplementME.ConversationEvent {
                    }
                    /**
                        * @hidden
                        */
                    interface ConversationServiceEvent extends ImplementME.ConversationServiceEvent {
                    }
                    /**
                        * @hidden
                        */
                    interface ErrorEvent extends ImplementME.ErrorEvent {
                    }
                    /**
                        * @hidden
                        */
                    interface MessageEvent extends ImplementME.MessageEvent {
                    }
                    /**
                        * @hidden
                        */
                    interface MessengerEvent extends ImplementME.MessengerEvent {
                    }
                    /**
                        * @hidden
                        */
                    interface RetransmitEvent extends ImplementME.RetransmitEvent {
                    }
                    /**
                        * @hidden
                        */
                    interface StatusEvent extends ImplementME.StatusEvent {
                    }
                    /**
                        * @hidden
                        */
                    interface SubscriptionEvent extends ImplementME.SubscriptionEvent {
                    }
                    /**
                        * @hidden
                        */
                    interface UserEvent extends ImplementME.UserEvent {
                    }
            }
            /**
                * Conversation instance. Created by the [Messenger.createConversation] method. Used to send messages, add or remove users, change moderators list etc.
                */
            class Conversation extends Implement.Conversation {
            }
            /**
                * Describes single message. Received via the [MessengerEvents.SendMessage] or [MessengerEvents.EditMessage] events and used to serialize or edit the message.
                */
            class Message extends Implement.Message {
            }
            /**
                * Messenger class is used to control messaging functions. Can't be instantiated directly (singleton), please use [getMessenger] to get the class instance.
                */
            class Messenger extends Implement.Messenger {
            }
            /**
                * User description returned by the [Messenger.getUser] method.
                */
            interface User extends Implement.User {
            }
            /**
                * User description for the conversation
                */
            interface ConversationParticipant extends Implement.ConversationParticipant {
            }
            /**
                * User status information available in the [MessengerEvents.SetStatus] event.
                */
            interface UserStatus extends Implement.UserStatus {
            }
            /**
                * Serialized conversation information that can be stored into some storage (like IndexedDB) and later restored via [Messenger.createConversationFromCache]
                */
            interface SerializedConversation extends Implement.SerializedConversation {
            }
            /**
                * Serialized message information that can be stored into some storage (like IndexedDB) and later restored via [Messenger.createMessageFromCache]
                */
            interface SerializedMessage extends Implement.SerializedMessage {
            }
            interface RetransmittedEvent extends Implement.RetransmittedEvent {
            }
            enum MessengerEvents {
                    /**
                        * New conversation created.
                        * You receive this event when anybody created a new conversation with the current user in participant array. Also this event dispatch on conversation creator.
                        */
                    CreateConversation = "CreateConversation",
                    /**
                        * Conversation properties were modified.
                        */
                    EditConversation = "EditConversation",
                    /**
                        * The conversation was removed.
                        */
                    RemoveConversation = "RemoveConversation",
                    /**
                        * Conversation description is received. Triggered in response to the 'getConversation'.
                        */
                    GetConversation = "GetConversation",
                    /**
                        * Event is triggered when a new message is received as a result of the [Conversation.sendMessage] method call.
                        */
                    SendMessage = "SendMessage",
                    /**
                        * Message was edited.
                        */
                    EditMessage = "EditMessage",
                    /**
                        * Message was removed.
                        */
                    RemoveMessage = "RemoveMessage",
                    /**
                        * Information that some user is typing something is received. Triggered in response to the 'typing' called by any user.
                        */
                    Typing = "Typing",
                    /**
                        * Dispatch when [Messenger.editUser] successful done into cloud. Triggered only for users specified in the 'subscribe' method call.
                        */
                    EditUser = "EditUser",
                    /**
                        * Return user, requested in [Messenger.getUser] function
                        */
                    GetUser = "GetUser",
                    /**
                        * Event is triggered in case of an error while creating a conversation. See the details in the [MessengerEventsCallbacks.ErrorEvent] interface.
                        */
                    Error = "Error",
                    /**
                        * Event is triggered after [Conversation.retransmitEvents] method is called on some conversation for this SDK instance.
                        */
                    RetransmitEvents = "RetransmitEvents",
                    /**
                        *  Event is triggered after another device with same logged in user called the [Conversation.markAsRead] method.
                        */
                    Read = "Read",
                    /**
                        * Event is triggered after another device with same logged in user called the [Conversation.markAsDelivered] method.
                        */
                    Delivered = "Delivered",
                    /**
                        * Event is triggered after the [Messenger.subscribe] method is called.
                        */
                    Subscribe = "Subscribe",
                    /**
                        * Event is triggered after the [Messenger.unsubscribe] method is called.
                        */
                    Unsubscribe = "Unsubscribe",
                    /**
                        * Event is triggered after the user presence state has changed.
                        */
                    SetStatus = "SetStatus"
            }
            /**
                * Available methods to manipulate the messaging flow. Note if the action triggers any of [MessengerEvents], the action's name will be set as a value of [ConversationEvent.messengerAction].
                */
            enum MessengerAction {
                    createConversation,
                    editConversation,
                    removeConversation,
                    joinConversation,
                    leaveConversation,
                    getConversation,
                    getConversations,
                    sendMessage,
                    editMessage,
                    removeMessage,
                    typingMessage,
                    editUser,
                    getUser,
                    getUsers,
                    retransmitEvents,
                    isRead,
                    isDelivered,
                    addParticipants,
                    editParticipants,
                    removeParticipants,
                    addModerators,
                    removeModerators,
                    subscribe,
                    unsubscribe,
                    setStatus
            }
            /**
                *
                */
            enum MessengerError {
                    /**
                        * Wrong transport message structure
                        */
                    Error_1,
                    /**
                        * Unknown event name
                        */
                    Error_2,
                    /**
                        * User not auth
                        */
                    Error_3,
                    /**
                        * Wrong message structure
                        */
                    Error_4,
                    /**
                        * Conversation not found or user not in participant list
                        */
                    Error_5,
                    /**
                        * Conversation not found or user can't moderate conversation
                        */
                    Error_6,
                    /**
                        * Conversation already exists
                        */
                    Error_7,
                    /**
                        * Conversation does not exist
                        */
                    Error_8,
                    /**
                        * Message already exists
                        */
                    Error_9,
                    /**
                        * Message does not exist
                        */
                    Error_10,
                    /**
                        * Message was deleted
                        */
                    Error_11,
                    /**
                        * ACL error
                        */
                    Error_12,
                    /**
                        * User already in participant list
                        */
                    Error_13,
                    /**
                        * No rights to edit user
                        */
                    Error_14,
                    /**
                        * Public join is not available in this conversation
                        */
                    Error_15,
                    /**
                        * Conversation was deleted
                        */
                    Error_16,
                    /**
                        * Conversation is distinct
                        */
                    Error_17,
                    /**
                        * User validation Error
                        */
                    Error_18,
                    /**
                        * Lists mismatch
                        */
                    Error_19,
                    /**
                        * Range larger then allowed by service
                        */
                    Error_21,
                    /**
                        * Number of requested objects is larger then allowed by service
                        */
                    Error_22,
                    /**
                        * Message size so large
                        */
                    Error_23,
                    /**
                        * Seq is too big
                        */
                    Error_24,
                    /**
                        * IM service not available
                        */
                    Error_30,
                    /**
                        * Internal error
                        */
                    Error_500,
                    /**
                        * Oops! Something went wrong
                        */
                    Error_777
            }
    }
    export default Messaging;
}

declare module 'voximplant-websdk/Structures' {
    import { TrackType } from "voximplant-websdk/Types";
    import { CallMode, CallState } from "voximplant-websdk/Call/Call";
    import { LogCategory, LogLevel } from "voximplant-websdk/Logger";
    /**
        *    VoxImplant SDK Configuration
        */
    export interface Config {
            /**
                * Reconnect to IM subsystem automatically
                * @hidden
                */
            imAutoReconnect?: boolean;
            /**
                * Interval (ms) before reconnect
                * @hidden
                */
            imReconnectInterval?: number;
            /**
                * XSS protection for inbound instant messages that can contain HTML content
                * @hidden
                */
            imXSSprotection?: boolean;
            /**
                * If it's true a microphone access dialog will be shown and all functions will become available only after user granted access
                */
            micRequired?: boolean;
            /**
                * Automatically plays progress tone by means of SDK according to specified progressToneCountry. It's true by default.
                */
            progressTone?: boolean;
            /**
                * Country code for progress tone generated automatically if *progressTone* is set to true. Available values are: RU, US
                */
            progressToneCountry?: string;
            /**
                * Show debug info in console. It's false by default.
                */
            showDebugInfo?: boolean;
            /**
                * Show warnings. It's false by default.
                */
            showWarnings?: boolean;
            /**
                * Default constraints that will be applied on the next attachRecordingDevice function call or if micRequired set to true. *IMPORTANT*: the value has to be the [VideoSettings] object. *Boolean* values exist only in order to ensure backward compatibility.
                */
            videoConstraints?: VideoSettings | boolean;
            /**
                * IP address of particular media gateway for connection
                */
            serverIp?: Array<string> | string;
            /**
                * Id of HTMLElement that will be used as a default container for local video elements, i.e. caller could see himself in this container during the conversation. Local videos are appended to the body element by default.
                * @see remoteVideoContainerId
                * @see localVideoContainerId
                * @deprecated
                */
            videoContainerId?: string;
            /**
                * Id of HTMLElement that will be used as a default container for remote video elements. Remote videos are appended to the body element by default
                *
                */
            remoteVideoContainerId?: string;
            /**
                * Id of HTMLElement that will be used as a default container for local video elements. Local videos are appended to the body element by default
                *
                */
            localVideoContainerId?: string;
            /**
                * *DEPRECATED*
                * Request video access rights immediately.
                * @deprecated
                * @hidden
                */
            videoSupport?: boolean;
            /**
                * Set sdk protocol manual. Can be "2" or "3"
                * @hidden
                */
            protocolVersion?: string;
            /**
                * Use H264 video codec, if it's available on the target device
                */
            H264first?: boolean;
            /**
                * RTC Stats collection interval (ms)
                */
            rtcStatsCollectionInterval?: number;
            /**
                * Params for <a href="https://calstats.io/">https://calstats.io/</a> integration
                */
            callstatsIoParams?: CallstatsIoParams;
            /**
                * Use VP8 video codec, if exist
                * @hidden
                */
            VP8first?: boolean;
            /**
                * @hidden
                */
            prettyPrint?: boolean;
            /**
                * @hidden
                */
            experiments?: any;
            /**
                * @hidden
                */
            tryingServers?: Array<string>;
    }
    /**
        * WebRTC Video Settings (aka Constraints)
        * @hidden
        *
        * @deprecated
        */
    export interface VideoSettings {
            /**
                * The width or width range, in pixels
                */
            width?: number | any;
            /**
                * The height or height range, in pixels
                */
            height?: number | any;
            /**
                * The exact aspect ratio (width in pixels divided by height in pixels, represented as a double rounded to the tenth decimal place) or aspect ratio range
                */
            aspectRatio?: number | any;
            /**
                * The exact frame rate (frames per second) or frame rate range
                */
            frameRate?: number | any;
            /**
                * This string (or each string, when a list) should be one of the members of VideoFacingModeEnum
                */
            facingMode?: string | any;
            /**
                * The origin-unique identifier for the source of the MediaStreamTrack
                */
            deviceId?: string;
            /**
                * The origin-unique group identifier for the source of the MediaStreamTrack. Two devices have the same group identifier if they belong to the same physical device
                */
            groupId?: string;
            /**
                *    Mandatory constraints object
                */
            mandatory?: Object;
            /**
                *    Optional constraints object
                */
            optional?: Object;
    }
    /**
        * Audio recording device info
        */
    export interface AudioSourceInfo {
            /**
                * Device id that can be used to choose audio playback device, see [Client.useAudioOutput]
                */
            id: number | string;
            /**
                * Device name
                */
            name: string;
            group: string;
    }
    /**
        * Video recording device info
        */
    export interface VideoSourceInfo {
            /**
                * Device id that can be used to choose video recording device, see [Client.useVideoSource]
                */
            id: number | string;
            /**
                * Device name
                */
            name: string;
            group: string;
    }
    /**
        * Audio playback device info
        * @class
        * @hidden
        * @deprecated
        */
    export interface AudioOutputInfo {
            /**
                * Device id that can be used to choose audio playback device, see [Client.useAudioOutput]</a>
                */
            id: number | string;
            /**
                * Device name, in WebRTC mode populated with real data only when application has been opened using HTTPS protocol
                */
            name: string;
            /**
                * @hidden
                */
            group: string;
    }
    /**
        * Network information
        * @hidden
        * @deprecated
        */
    export interface NetworkInfo {
            /**
                * Packet loss percentage
                */
            packetLoss: number;
    }
    /**
        * Enumeration of ACD statuses, use
        * [Client.setOperatorACDStatus] to set the status.
        *  For detailed information of ACD concept see the <a href="https://voximplant.com/docs/references/appengine/Module_ACD.html">Modules.ACD</a> documentation and the <a href="http://voximplant.com/docs/howto/#callcenter">appropriate HowTo's</a>.
        *
        * <img src="//voximplant.com/assets/images/2018/03/13/acdflow-2018-updated.svg" style="width: 500px;display: block;margin: 10px auto 0 auto;"/>
        *
        *
        * Example:
        * ``` js
        * // Enable ACD module
        * require(Modules.ACD);
        * //create Client instance and connect to the cloud
        * var vox = VoxImplant.getInstance();
        * vox.init({micRequired: true});
        * vox.addEventListener(VoxImplant.Events.SDKReady, function() {
        *   vox.connect();
        * });
        * //set the operator's status
        * vox.setOperatorACDStatus(VoxImplant.OperatorACDStatuses.Ready);
        * ```
    
        */
    export enum OperatorACDStatuses {
            /**
                * Operator is offline
                *
                *
                * <strong>Recommended logic flow</strong>
                *
                * |From status  |This status|To status|
                * |-------------|-----------|---------|
                * |NONE         |OFFLINE    |ONLINE   |
                * |ONLINE       |OFFLINE    |ONLINE   |
                * |READY        |OFFLINE    |ONLINE   |
                * |AFTER_SERVICE|OFFLINE    |ONLINE   |
                * |DND          |OFFLINE    |ONLINE   |
                * |TIMEOUT      |OFFLINE    |ONLINE   |
                *
                */
            Offline,
            /**
                * The operator is logged in, but not ready to handle incoming calls yet
                *
                *
                * <strong>Recommended logic flow</strong>
                *
                * |From status  |This status|To status|
                * |-------------|-----------|---------|
                * |OFFLINE      |ONLINE     |READY    |
                * |READY        |OFFLINE    |ONLINE   |
                *
                * <strong>!!! Set status to ONLINE and then to READY, if you want to flush operator's ban (after missed call)</strong>
                */
            Online,
            /**
                * Ready to handle incoming calls
                *
                *
                * <strong>Recommended logic flow</strong>
                *
                * |From status  |This status|To status |
                * |-------------|-----------|----------|
                * |OFFLINE      |READY      |IN_SERVICE|
                * |DND          |READY      |ONLINE    |
                * |AFTER_SERVICE|READY      |DND       |
                * |TIMEOUT      |READY      |TIMEOUT   |
                *
                */
            Ready,
            /**
                * Incoming call is in service
                *
                *
                * <strong>Recommended logic flow</strong>
                *
                * |From status|This status|To status    |
                * |-----------|-----------|-------------|
                * |READY      |IN_SERVICE |AFTER_SERVICE|
                *
                */
            InService,
            /**
                * An incoming call has ended and now an operator is processing after service work.
                *
                *
                * <strong>Recommended logic flow</strong>
                *
                * |From status|This status  |To status|
                * |-----------|-------------|---------|
                * |IN_SERVICE |AFTER_SERVICE|READY    |
                * |IN_SERVICE |AFTER_SERVICE|TIMEOUT  |
                * |IN_SERVICE |AFTER_SERVICE|DND      |
                * |IN_SERVICE |AFTER_SERVICE|OFFLINE  |
                *
                */
            AfterService,
            /**
                * The operator is on a break (e.g. having lunch).
                *
                *
                * <strong>Recommended logic flow</strong>
                *
                * |From status  |This status|To status|
                * |-------------|-----------|---------|
                * |READY        |TIMEOUT    |READY    |
                * |AFTER_SERVICE|TIMEOUT    |READY    |
                *
                */
            Timeout,
            /**
                * The operator is busy now and not ready to handle incoming calls (e.g. working on another call)
                *
                *
                * <strong>Recommended logic flow</strong>
                *
                * |From status  |This status|To status|
                * |-------------|-----------|---------|
                * |READY        |DND        |READY    |
                * |AFTER_SERVICE|DND        |READY    |
                *
                */
            DND
    }
    /**
        * VoxImplant login options
        * @class
        */
    export interface LoginOptions {
            /**
                * If set to false Web SDK can be used only for ACD status management
                */
            receiveCalls?: boolean;
            /**
                * If set to true user presence will be changed automatically while a call is in progress
                * @hidden
                */
            serverPresenceControl?: boolean;
            /**
                * @hidden
                */
            accessToken?: string;
            /**
                * A unique token for the current device. Use Client.getGUID() and save it at client storage (foe LocalStorage or IndexedDB)
                * @hidden
                */
            deviceToken?: string;
            /**
                * @hidden
                */
            mediaServer?: string;
    }
    export interface CallSettings {
            /**
                * The number to call. The international format E.164 is preferable
                */
            number: string;
            /**
                * Tells if video should be supported for the call
                */
            video?: VideoFlags | boolean;
            /**
                * Auto wire local streams to participants
                * if false - create empty localStream from audio api to generate sdp
                * @hidden
                */
            wiredLocal?: boolean;
            /**
                * Auto wire remote streams to DOM elements
                * @hidden
                */
            wiredRemote?: boolean;
            /**
                * Optional custom parameters (SIP headers) that should be passed with call (INVITE) message. Parameter names must start with "X-" to be processed by application. IMPORTANT: Headers size limit is 200 bytes.
                */
            extraHeaders?: {
                    [id: string]: string;
            };
            /**
                * Custom string associated with the call session. It can be passed to the cloud to be obtained from the [CallAlerting](https://voximplant.com/docs/references/voxengine/appevents#callalerting) event or [Call History](https://voximplant.com/docs/references/httpapi/managing_history#getcallhistory) using HTTP API. Maximum size is 200 bytes. Use the [Call.sendMessage] method to pass a string over the limit; in order to pass a large data use [media_session_access_url](https://voximplant.com/docs/references/httpapi/managing_scenarios#startscenarios) on your backend.
                */
            customData?: string;
            /**
                * @deprecated
                * @hidden
                */
            extraParams?: {
                    [id: string]: string;
            };
            /**
                * Use H264 video codec, if exist
                */
            H264first?: boolean;
            /**
                * Use VP8 video codec, if exist
                * @hidden
                */
            VP8first?: boolean;
            /**
                * @hidden
                */
            forceActive?: boolean;
            /**
                * @hidden
                */
            isConference?: boolean;
    }
    /**
        * @hidden
        */
    export interface InnerCallSettings extends CallSettings {
            id: string;
            displayName: string;
            active: boolean;
            state: CallState;
            mode: CallMode;
            usedSinkId: number | string;
            videoDirections: VideoFlags;
            hasEarlyMedia: boolean;
            audioDirections: AudioFlags;
            incoming: boolean;
    }
    /**
        * Call disconnecting flags
        */
    export interface DisconnectingFlags {
            /**
                * It is true, when call is answered elsewhere
                */
            answeredElsewhere: boolean;
    }
    /**
        * Structure for callstats.io integration,
        * see https://www.callstats.io/api/
        */
    export interface CallstatsIoParams {
            /**
                * Application ID is obtained from callstats.io.
                */
            AppID: string;
            /**
                * Application secret is obtained from callstats.io.
                */
            AppSecret: string;
            /**
                * If it's true it disables callstats.js’s *window.onbeforeunload* parameter. It's false by default.
                */
            disableBeforeUnloadHandler?: boolean;
            /**
                * Application version specified by the developer.
                */
            applicationVersion?: string;
    }
    export interface LoginTokens {
            /**
                * You can use this token for login before accessExpire.
                */
            accessToken: string;
            /**
                * Refresh token. You can use it 1 time before refreshExpire.
                */
            refreshToken: string;
            /**
                * Seconds before the access token expiration (in UNIX timestamp format)
                */
            accessExpire: number;
            /**
                * Seconds before the refresh token expiration (in UNIX timestamp format)
                */
            refreshExpire: number;
    }
    /**
        * Video direction settings for <a href="../classes/client.html#call">Client.call()</a> and <a href="../classes/call.html#answer">Call.answer()</a>
        */
    export interface VideoFlags {
            /**
                * Set to true if you want to send video to the remote participant. It's false by default.
                */
            sendVideo: boolean;
            /**
                * Set to true if you want to receive video from remote participant. It's false by default. If it's false and an incoming call sends a video stream, the call will provide only an audio stream.
                */
            receiveVideo: boolean;
    }
    /**
        * @hidden
        */
    export interface AudioFlags {
            sendAudio: boolean;
    }
    /**
        * @hidden
        */
    export interface reinviteDescription {
            tracks: {
                    [id: string]: TrackType;
            };
            restartTransport?: boolean;
    }
    /**
        * Structure for outer logging
        */
    export interface LogRecord {
            /**
                * The text that is displayed in the browser console.
                */
            formattedText: string;
            /**
                * Name of the module that creates a record.
                */
            category: LogCategory;
            /**
                * Record label
                */
            label: string;
            /**
                * Possible LogLevel values:
                *
                * |Value|Mean   |
                * |-----|-------|
                * |1    |ERROR  |
                * |2    |WARNING|
                * |3    |INFO   |
                * |4    |TRACE  |
                *
                */
            level: LogLevel;
            /**
                * Record message
                */
            message: string;
    }
}

declare module 'voximplant-websdk/Logger' {
    /**
        * @hidden
        */
    export enum LogLevel {
            NONE = 0,
            ERROR = 1,
            WARNING = 2,
            INFO = 3,
            TRACE = 4
    }
    /**
        * @hidden
        */
    export enum LogCategory {
            SIGNALING = 0,
            RTC = 1,
            USERMEDIA = 2,
            CALL = 3,
            CALLEXP2P = 4,
            CALLEXSERVER = 5,
            CALLMANAGER = 6,
            CLIENT = 7,
            AUTHENTICATOR = 8,
            PCFACTORY = 9,
            UTILS = 10,
            ORTC = 11,
            MESSAGING = 12,
            REINVITEQ = 13,
            HARDWARE = 14,
            ENDPOINT = 15,
            EVENTTARGET = 16
    }
    /**
        * The client states
        */
    export enum ClientState {
            /**
                * The client is currently disconnected
                */
            DISCONNECTED,
            /**
                * The client is currently connecting
                */
            CONNECTING,
            /**
                * The client is currently connected
                */
            CONNECTED,
            /**
                * The client is currently logging in
                */
            LOGGING_IN,
            /**
                * The client is currently logged in
                */
            LOGGED_IN
    }
    /**
        * Common logger
        * @hidden
        */
    export class Logger {
            constructor(category: LogCategory, label: string, provider: LogManager);
            log(level: LogLevel, message: string): void;
            error(message: string): void;
            warning(message: string): void;
            info(message: string): void;
            trace(message: string): void;
    }
    /**
        * @hidden
        */
    export class LogManager {
            static tick: number;
            shadowLogging: boolean;
            static get(): LogManager;
            static d_trace(category: LogCategory): (target: any, key: string, value: any) => {
                    value: (...args: any[]) => any;
            };
            getSLog(): Array<string>;
            clearSilentLog(): void;
            setLoggerCallback(callback: {
                    (record: {
                            formattedText: string;
                            category: LogCategory;
                            label: string;
                            level: LogLevel;
                            message: string;
                    }): void;
            }): void;
            setPrettyPrint(state: boolean): void;
            setLogLevel(category: LogCategory, level: LogLevel): void;
            writeMessage(category: LogCategory, label: string, level: LogLevel, message: string): void;
            createLogger(category: LogCategory, label: string): Logger;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
    }
}

declare module 'voximplant-websdk/Hardware/index' {
    import * as Implement from 'voximplant-websdk/Hardware/src';
    export module Hardware {
            /**
                * Events that are triggered when hardware device is added/removed/updated.
                */
            enum HardwareEvents {
                    /**
                        * Event is triggered each time when device is added/removed. Devices that trigger the event: microphones, video camera and sound output (available only in Google Chrome).
                        */
                    DevicesUpdated,
                    /**
                        * Event is triggered when local video or audio is started. E.g. when local video or screen sharing is stared.
                        */
                    MediaRendererAdded,
                    /**
                        * Event is triggered when local video or audio streaming is stopped. E.g. when local video or screen sharing streaming is stopped.
                        */
                    MediaRendererRemoved,
                    /**
                        * Event is triggered before local video or audio streaming is stopped. E.g. before local video or screen sharing streaming is stopped.
                        */
                    BeforeMediaRendererRemoved
            }
            /**
                * Enum that represents video quality.
                */
            enum VideoQuality {
                    /**
                        * Set better video quality for the current web camera.
                        * This option uses the last value from the [CameraManager.testResolutions] function result,
                        * or the data set to the [CameraManager.loadResolutionTestResult].
                        * If there is no result for a target web camera, use 1280x720 resolution
                        */
                    VIDEO_QUALITY_HIGH,
                    /**
                        * Set medium video quality for the current web camera.
                        * This option uses the last value from the [CameraManager.testResolutions] function result,
                        * or the data set to the [CameraManager.loadResolutionTestResult].
                        * If there is no result for a target web camera, use 640x480 resolution
                        */
                    VIDEO_QUALITY_LOW,
                    /**
                        * Set lower video quality for the current web camera.
                        * This option uses the last value from the [CameraManager.testResolutions] function result,
                        * or the data set to the [CameraManager.loadResolutionTestResult].
                        * If there is no result for a target web camera, use 320x240 resolution
                        */
                    VIDEO_QUALITY_MEDIUM,
                    /**
                        * 160x120 resolution
                        */
                    VIDEO_SIZE_QQVGA,
                    /**
                        * 176x144 resolution
                        */
                    VIDEO_SIZE_QCIF,
                    /**
                        * 320x240 resolution
                        */
                    VIDEO_SIZE_QVGA,
                    /**
                        * 352x288 resolution
                        */
                    VIDEO_SIZE_CIF,
                    /**
                        * 640x360 resolution
                        */
                    VIDEO_SIZE_nHD,
                    /**
                        * 640x480 resolution
                        */
                    VIDEO_SIZE_VGA,
                    /**
                        * 800x600 resolution
                        */
                    VIDEO_SIZE_SVGA,
                    /**
                        * 1280x720 resolution
                        */
                    VIDEO_SIZE_HD,
                    /**
                        * 1600x1200 resolution
                        */
                    VIDEO_SIZE_UXGA,
                    /**
                        * 1920x1080 resolution
                        */
                    VIDEO_SIZE_FHD,
                    /**
                        * 3840x2160 resolution
                        */
                    VIDEO_SIZE_UHD
            }
            /**
                * Interface that may be used to manage audio devices, i.e. see current active device, select another active device and get the list of available devices.
                */
            class AudioDeviceManager extends Implement.AudioDeviceManager {
            }
            /**
                * Audio constraints. Audio device will be chosen according to these settings.</br>
                * Settings are specified via
                * [AudioDeviceManager.setDefaultAudioSettings]
                *   and
                *   [AudioDeviceManager.setCallAudioSettings].
                */
            interface AudioParams extends Implement.AudioParams {
            }
            /**
                * Interface that may be used to manage cameras on Android device.
                */
            class CameraManager extends Implement.CameraManager {
            }
            /**
                * Camera constraints. Hardware camera will be chosen according to these settings.</br>
                * Settings are specified via
                * [CameraManager.setDefaultVideoSettings]
                *   and [CameraManager.setCallVideoSettings].
                */
            interface CameraParams extends Implement.CameraParams {
            }
            /**
                * @hidden
                */
            interface SharingStream extends Implement.SharingStream {
            }
            /**
                * Interface for extended management of local audio/video streams.
                */
            class StreamManager extends Implement.StreamManager {
            }
            /**
                * @hidden
                */
            class IOSCacheManager extends Implement.IOSCacheManager {
            }
    }
    export default Hardware;
}

declare module 'voximplant-websdk/Call/Call' {
    import { CallEvents } from 'voximplant-websdk/Call/CallEvents';
    import { VideoSettings, CallSettings, DisconnectingFlags, VideoFlags, InnerCallSettings } from 'voximplant-websdk/Structures';
    import { Logger } from 'voximplant-websdk/Logger';
    import { PeerConnection } from 'voximplant-websdk/PeerConnection/PeerConnection';
    import { CallManager } from 'voximplant-websdk/Call/CallManager';
    import { CodecSorterUserCodecList } from 'voximplant-websdk/PeerConnection/SDP/Interfaces';
    import { EventTarget } from 'voximplant-websdk/EventTarget';
    import { EventHandlers } from 'voximplant-websdk/EventHandlers';
    import { Endpoint } from 'voximplant-websdk/Call/EndPoints/Endpoint';
    /**
        * @hidden
        */
    export enum CallState {
            ALERTING,
            PROGRESSING,
            CONNECTED,
            UPDATING,
            ENDED
    }
    /**
        * @hidden
        */
    export enum CallMode {
            P2P = 0,
            SERVER = 1
    }
    /**
        *
        */
    export abstract class Call extends EventTarget<CallEvents> {
            /**
                * @hidden
                */
            signalingConnected: boolean;
            /**
                * @hidden
                */
            settings: InnerCallSettings;
            /**
                * Callback for manual rearrangement or setup compatible codec list. If will set unknown/unsupported codec - it will
                * be ignored
                * @example
                * // example sorting video section to set h264 first
                * var currentCall = vox.call("exampleUser");
                * currentCall.rearangeCodecs = function(codecList){
                *   return new Promise(function(resolve,reject){
                *     for(var i=0;i<codecList.sections.length;i++){
                *       if(codecList.sections[i].kind.toLowerCase()=="video"){
                *         codecList.sections[i].codec.sort((a:string,b:string)=>{
                *           if(a.toLowerCase().indexOf("h264")!=-1
                *            &&a.toLowerCase().indexOf("uc")==-1)
                *              return -1;
                *           if(b.toLowerCase().indexOf("h264")!=-1
                *            &&b.toLowerCase().indexOf("uc")==-1)
                *              return 1;
                *           return 0;
                *         })
                *       }
                *     }
                *     resolve(codecList);
                *   })
                * };
                */
            rearangeCodecs: (codecList: CodecSorterUserCodecList, incoming?: boolean) => Promise<CodecSorterUserCodecList>;
            /**
                * @hidden
                */
            protected log: Logger;
            /**
                * @hidden
                */
            protected _callManager: CallManager;
            /**
                * @hidden
                */
            constructor(id: string, dn: string, incoming: boolean, settings: CallSettings);
            /**
                * @hidden
                */
            protected _promise: Promise<Object>;
            /**
                * @hidden
                * @returns {Promise<Object>}
                */
            readonly promise: Promise<Object>;
            /**
                * @hidden
                */
            protected _peerConnection: PeerConnection;
            /**
             * @hidden
             * @param peerConnection
             */
            peerConnection: PeerConnection;
            /**
                * @hidden
                * @returns {CallState}
                */
            readonly stateValue: CallState;
            /**
                * Returns call id
                * @returns {String}
                */
            id(): string;
            /**
                * Returns dialed number or caller id
                * @returns {String}
                */
            number(): string;
            /**
                * Returns display name, i.e. a name of the calling user, that will be displayed to the called user. Normally it's a human-readable version of CallerID, e.g. a person's name.
                */
            displayName(): string;
            /**
                * Returns headers
                * @returns {Object}
                */
            headers(): {
                    [id: string]: string;
            };
            /**
                * Returns 'true' if a call is active, otherwise returns 'false'. A single call (either inbound or outbound) is active by default, all other calls are inactive and should be activated via the <a href="#setactive">setActive</a> method. Only the active call sends and receives an audio/video stream.
                */
            active(): boolean;
            /**
                * Get the current state of a call.
                * Possible values are: "ALERTING", "PROGRESSING", "CONNECTED", "ENDED".
                * @returns {String}
                */
            state(): string;
            /**
                * Answer the incoming call. There are two methods for an <a href="//voximplant.com/refs/websdk/enums/events.html#incomingcall">incoming call</a>: <a href="#answer">answer</a> and <a href="#decline">decline</a>. Voice can be sended only after the <a href="#answer">answer</a> method call.
                * @param {String} customData Set custom string associated with call session. It can be later obtained from Call History <a href="//voximplant.com/docs/references/httpapi/#toc-getcallhistory">using HTTP API</a>, see the <a href="//voximplant.com/docs/references/httpapi/#struct_CallSessionInfoType">custom_data field in result</a>. Custom data can be retrieved on the part of Voxengine via the <a href="//voximplant.com/docs/references/appengine/VoxEngine.html#VoxEngine_customData">customData</a> method. Maximum size is 200 bytes.
                * @param {Object} extraHeaders Optional custom parameters (SIP headers) that are sent to another participant after accepting an incoming call. Header names have to begin with the 'X-' prefix. The "X-" headers could be handled only by SIP phones/devices.
                * @param {VideoFlags} useVideo [A set of flags](https://voximplant.com/docs/references/websdk/voximplant/videoflags) defining if sending and receiving video is allowed.
                */
            answer(customData?: string, extraHeaders?: {
                    [id: string]: string;
            }, useVideo?: VideoFlags): void;
            /**
                * Reject incoming call on all devices, where this user logged in.
                * @param {Object} extraHeaders Optional custom parameters (SIP headers) that should be sent after rejecting incoming call. Parameter names must start with "X-" to be processed by application
                */
            decline(extraHeaders?: {
                    [id: string]: string;
            }): void;
            /**
                * Reject incoming call on the part of Web SDK. If a call is initiated from the PSTN, the network will receive "reject" command; in case of a call from another Web SDK client, it will receive the [CallEvents.Failed] event with the 603 code.
                * @param {Object} extraHeaders Optional custom parameters (SIP headers) that should be sent after rejecting incoming call. Parameter names must start with "X-" to be processed by application
                */
            reject(extraHeaders?: {
                    [id: string]: string;
            }): void;
            /**
                * Hangup call
                * @param {[id:string]:string} extraHeaders Optional custom parameters (SIP headers) that should be sent after disconnecting/cancelling call. Parameter names must start with "X-" to be processed by application
                */
            hangup(extraHeaders?: {
                    [id: string]: string;
            }): void;
            /**
                * Send tone (DTMF). It triggers the <a href="https://voximplant.com/docs/references/appengine/CallEvents.html#CallEvents_ToneReceived">CallEvents.ToneReceived</a> event in our cloud.
                * @param {String} key Send tone according to pressed key: 0-9 , * , #
                */
            sendTone(key: string): void;
            /**
                * Mute sound
                */
            mutePlayback(): void;
            /**
                * Unmute sound
                */
            unmutePlayback(): void;
            /**
                * @hidden
                */
            restoreRMute(): void;
            /**
                * Mute microphone
                */
            muteMicrophone(): void;
            /**
                * Unmute microphone
                */
            unmuteMicrophone(): void;
            /**
                * Show/hide remote party video. *IMPORTANT*: Safari browser for iOS requires a user interface for playing video during a call. It should be interactive element like an HTML "button" with "onclick" handler that calls "play" method on the "video" HTML element.
                * @param {Boolean} [flag=true] Show/hide - true/false
                * @deprecated
                * @hidden
                */
            showRemoteVideo(flag?: boolean): void;
            /**
                * Set remote video position
                * @param {Number} x Horizontal position (px)
                * @param {Number} y Vertical position (px)
                * @function
                * @hidden
                */
            setRemoteVideoPosition(x: number, y: number): void;
            /**
                * Set remote video size
                * @param {Number} width Width in pixels
                * @param {Number} height Height in pixels
                * @function
                * @deprecated
                * @hidden
                */
            setRemoteVideoSize(width: number, height: number): void;
            /**
                * Send Info (SIP INFO) message inside the call
                *
                * You can get this message via the Voxengine [CallEvents.InfoReceived] event in our cloud.
                *
                * You can get this message in Web SDK on other side via the [CallEvents.InfoReceived] event; see the similar events for the <a href="//voximplant.com/docs/references/mobilesdk/ios/all/index.html#//api/name/call:didReceiveInfo:type:headers:">iOS</a> and <a href="//voximplant.com/docs/references/mobilesdk/android/com/voximplant/sdk/call/ICallListener.html#onSIPInfoReceived-com.voximplant.sdk.call.ICall-java.lang.String-java.lang.String-java.util.Map-">Android</a> SDKs.
                * @param {String} mimeType MIME type of the message, e.g. "text/plain", "multipart/mixed" etc.
                * @param {String} body Message content
                * @param {[id:string]:string} extraHeaders Optional headers to be passed with the message
                */
            sendInfo(mimeType: string, body: string, extraHeaders?: {
                    [id: string]: string;
            }): void;
            /**
                * Send text message. It is a special case of the [sendInfo] method as it allows to send messages only of "text/plain" type.
                *
                * You can get this message via the Voxengine [CallEvents.MessageReceived] event in our cloud.
                *
                * You can get this message in Web SDK on other side via the [CallEvents.MessageReceived] event; see the similar events for the <a href="//voximplant.com/docs/references/mobilesdk/ios/all/index.html#//api/name/call:didReceiveMessage:headers:">iOS</a> and <a href="//voximplant.com/docs/references/mobilesdk/android/com/voximplant/sdk/call/ICallListener.html#onMessageReceived-com.voximplant.sdk.call.ICall-java.lang.String-">Android</a> SDKs.
                * @param {String} msg Message text
                */
            sendMessage(msg: string): void;
            /**
                * Set video settings
                * @param {VoxImplant.VideoSettings|VoxImplant.FlashVideoSettings} settings Video settings for current call
                * @param {Function} [successCallback] Called in WebRTC mode if video settings were applied successfully
                * @param {Function} [failedCallback] Called in WebRTC mode if video settings couldn't be applied
                * @deprecated
                * @hidden
                */
            setVideoSettings(settings: VideoSettings, successCallback?: Function, failedCallback?: Function): void;
            /**
                * Returns HTML video element's id for the call
                * @deprecated
                * @hidden
                */
            getVideoElementId(): string;
            /**
                * Register a handler for the specified event. One event can have more than one handler; handlers are executed in order of registration.
                * Use the [removeEventListener] method to delete a handler.
                * @param {Function} event Event class (i.e. [CallEvents.Connected]). See [CallEvents]
                * @param {Function} handler Handler function. A single parameter is passed - object with event information
                * @deprecated
                * @hidden
                */
            addEventListener(event: CallEvents, handler: Function): void;
            /**
                * Register a handler for the specified event. The method is a shorter equivalent for *addEventListener*. One event can have more than one handler; handlers are executed in order of registration.
                * Use the [Call.off] method to delete a handler.
                *
                *
                * @example
                *   var currentCall = vox.call("exampleUser");
                *   currentCall.on(VoxImplant.CallEvents.Connected,onConnected);
                *   currentCall.on(VoxImplant.CallEvents.Disconnected,onDisconnected);
                *   currentCall.on(VoxImplant.CallEvents.Failed,onFailed);
                *   currentCall.on(VoxImplant.CallEvents.ICETimeout,onICETimeout);
                * @param {Function} event Event class (i.e. [CallEvents.Connected]. See [CallEvents]
                * @param {Function} handler Handler function. A single parameter is passed - object with event information
                */
            on(event: CallEvents, handler: Function): void;
            /**
                * Remove handler for specified event
                * @param {Function} event Event class (i.e. [CallEvents.Connected]). See [CallEvents]
                * @param {Function} handler Handler function, if not specified all event handlers will be removed
                * @deprecated
                * @hidden
                */
            removeEventListener(event: CallEvents, handler?: Function): void;
            /**
                * Remove a handler for the specified event. The method is a shorter equivalent for *removeEventListener*. If a number of events has the same function as a handler, the method can be called multiple times with the same handler argument.
                * @param {Function} event Event class (i.e. [CallEvents.Connected]). See [VoxImplant.CallEvents].
                * @param {Function} handler Handler function, if not specified all event handlers will be removed
                * @function
                */
            off(event: CallEvents, handler?: Function): void;
            /**
                * @hidden
                */
            dispatchEvent(e: any): void;
            /**
                * @hidden
                * @param headers
                * @param sdp
                * @returns {boolean}
                */
            onConnected(headers: {
                    [id: string]: string;
            }, sdp: string): boolean;
            /**
                * @hidden
                * @param headers
                * @param params
                * @returns {boolean}
                */
            onDisconnected(headers: {
                    [id: string]: string;
            }, params: DisconnectingFlags): Promise<boolean>;
            /**
                * @hidden
                * @param code
                * @param reason
                * @param headers
                * @returns {boolean}
                */
            onFailed(code: number, reason: string, headers: {
                    [id: string]: string;
            }): boolean;
            /**
                * @hidden
                * @returns {boolean}
                */
            onStopRinging(): boolean;
            /**
                * @hidden
                * @returns {boolean}
                */
            onRingOut(): boolean;
            /**
                * @hidden
                * @returns {boolean}
                */
            onTransferComplete(): boolean;
            /**
                * @hidden
                * @returns {boolean}
                */
            onTransferFailed(): boolean;
            /**
                * @hidden
                * @param call
                * @param type
                * @param subType
                * @param body
                * @param headers
                * @returns {boolean}
                */
            onInfo(call: Call, type: string, subType: string, body: string, headers: {
                    [id: string]: string;
            }): boolean;
            /**
                *
                * The method makes a call active, i.e. change the [active] flag to 'true'.
                *  A single call (either inbound or outbound) is active by default, all other calls are inactive and should be activated.
                * @param {boolean} flag
                * @returns {Promise<EventHandlers.Updated>}
                */
            setActive(flag: boolean): Promise<EventHandlers.Updated>;
            /**
                * @hidden
                */
            checkCallMode(mode: CallMode): boolean;
            /**
                * @hidden
                */
            canStartSendingCandidates(): void;
            /**
                * @hidden
                */
            notifyICETimeout(): void;
            /**
                *  Start/stop sending video from a call. In case of a remote participant uses a Web SDK client, it will receive either the [EndpointEvents.RemoteMediaAdded] or [EndpointEvents.RemoteMediaRemoved] event accordingly.
                * *IMPORTANT*: Safari browser for iOS requires a user interface for playing video during a call. It should be interactive element like an HTML "button" with "onclick" handler that calls "play" method on the "video" HTML element.
                * @param flag
                */
            sendVideo(flag: boolean): Promise<EventHandlers.Updated>;
            /**
                * @hidden
                */
            receiveVideo(): Promise<EventHandlers.Updated>;
            /**
                * @hidden
                * @param audio
                * @param video
                */
            sendMedia(audio: boolean, video: boolean): Promise<EventHandlers.Updated>;
            /**
                * @hidden
                * @param flag
                */
            sendAudio(flag: boolean): Promise<EventHandlers.Updated>;
            /**
                * Get current PeerConnection LocalStream OR if set wiredLocal === false - try get newOne from UserMediaManager
                * @hidden
                * @deprecated
                */
            getLocalStream(): Promise<MediaStream>;
            /**
                * @hidden
                * @deprecated
                * @param stream
                * @returns {Promise<void>|Promise}
                */
            setLocalStream(stream: MediaStream): Promise<void>;
            /**
                * Enable screen sharing. Works in Chrome and Firefox. For Chrome, custom
                * extension must be created and installed from this template:
                * "https://github.com/voximplant/voximplant-chrome-extension". "matches"
                * section in the extension's "manifest.json" should be set to app website url(s).
                * Browser will ask user for a window or screen to share. Can be called multiple times
                * to share multiple windows.
                * @param {boolean} showLocalView if set to true, a screen sharing preview will be displayed locally in the same
                * way as it's done for video calls. It is false by default. *IMPORTANT*: Safari browser for iOS requires a user interface for playing video during a call. It should be interactive element like an HTML "button" with "onclick" handler that calls "play" method on the "video" HTML element.
                *
                */
            shareScreen(showLocalView?: boolean): Promise<EventHandlers.Updated>;
            /**
                * Stops screen sharing. If 'shareScreen' was called multiple times, this will stop
                * sharing for all windows/screens
                */
            stopSharingScreen(): Promise<EventHandlers.Updated>;
            /**
                * @hidden
                * @deprecated
                * @returns {Promise<void>|Promise}
                */
            wireRemoteStream(): Promise<void>;
            /**
                * @hidden
                * @returns {Promise<MediaStream>|Promise}
                */
            getRemoteAudioStreams(): Promise<MediaStream>;
            /**
                * @hidden
                * @deprecated
                * @returns {Promise<MediaStream>|Promise}
                */
            getRemoteVideoStreams(): Promise<MediaStream>;
            /**
                * get wired state for remote audio streams
                * @hidden
                * @deprecated
                * @returns {boolean}
                */
            getRemoteWiredState(): boolean;
            /**
                * get wired state for local audio streams
                * @hidden
                * @deprecated
                * @returns {boolean}
                */
            getLocalWiredState(): boolean;
            /**
                * Use specified audio output , use [audioOutputs] to get the list of available audio output
                * @param {String} id Id of the audio source
                * @hidden
                * @deprecated
                */
            useAudioOutput(id: string): Promise<void>;
            /**
                * Returns HTML audio element's id for the audio call
                * @returns string
                * @deprecated
                * @hidden
                */
            getAudioElementId(): string;
            /**
                * For testing and debug
                * @hidden
                */
            getDirections(): Object;
            /**
                * For testing and debug
                * @hidden
                */
            getStreamActivity(): Object;
            /**
                * @hidden
                */
            hdnFRS(): void;
            /**
                * @hidden
                */
            hdnFRSPrep(): void;
            /**
                * @hidden
                * @param headers
                * @param sdp
                */
            runIncomingReInvite(headers: {
                    [id: string]: string;
            }, sdp: string): void;
            /**
                * @hidden
                * @param state
                */
            setActiveForce(state: any): void;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
            /**
                * Get the call duration
                * @return the call duration in milliseconds
                */
            getCallDuration(): number;
            /**
                * Get all current [Endpoints] in the call.
                * @returns {Endpoint[]}
                */
            getEndpoints(): Endpoint[];
    }
}

declare module 'voximplant-websdk/Signaling/VoxSignalingHandler' {
    /**
      * Handler of signaling connection events
      * @hidden
      */
    export interface VoxSignalingHandler {
        onSignalingConnected(): any;
        onSignalingClosed(): any;
        onSignalingConnectionFailed(errorMessage: string): any;
        onMediaConnectionFailed(): any;
    }
}

declare module 'voximplant-websdk/EventTarget' {
    /**
        * @hidden
        */
    export abstract class EventTarget<EventType> {
            /**
                * @hidden
                * @type {{}}
                */
            eventListeners: any;
            /**
                * @hidden
                * @type {{}}
                */
            defaultEventListeners: any;
            /**
                * @hidden
                * @deprecated
                * @param {EventType} event
                * @param {Function} handler
                */
            addEventListener(event: EventType, handler: Function): void;
            /**
                * @hidden
                * @param {EventType} event
                * @param {Function} handler
                */
            addDefaultEventListener(event: EventType, handler?: Function): void;
            /**
                * @hidden
                * @param {EventType} event
                */
            removeDefaultEventListener(event: EventType): void;
            /**
                * @hidden
                * @param e
                */
            dispatchEvent(e: any): void;
            /**
                * @hidden
                * @deprecated
                * @param {EventType} event
                * @param {Function} handler
                */
            removeEventListener(event: EventType, handler?: Function): void;
            on(event: EventType, handler: Function): void;
            off(event: EventType, handler?: Function): void;
    }
}

declare module 'voximplant-websdk/Legacy/ZingayaAPI' {
    import { Client } from "voximplant-websdk/Client";
    /**
        * @hidden
        */
    export class ZingayaAPI {
            /**
                * @hidden
                */
            onConnectionFailed: any;
            /**
                * @hidden
                */
            onConnectionEstablished: any;
            /**
                * @hidden
                */
            onCheckComplete: any;
            /**
                * @hidden
                */
            onCallFailed: any;
            /**
                * @hidden
                */
            onCallConnected: any;
            /**
                * @hidden
                */
            onCallEnded: any;
            /**
                * @hidden
                */
            onCallRinging: any;
            /**
                * @hidden
                */
            onCallMediaStarted: any;
            /**
                * @hidden
                */
            onVoicemail: any;
            /**
                * @hidden
                */
            onNetStatsReceived: any;
            /**
                * @hidden
                * @param client
                */
            constructor(client: Client);
            /**
                * @hidden
                * @param serverAddress
                * @param referrer
                * @param extra
                * @param appName
                */
            connectTo(serverAddress: string, referrer: string, extra: any, appName: string): void;
            /**
                * @hidden
                */
            connect(): void;
            /**
                * @hidden
                * @param video
                * @param onMediaAccessGranted
                * @param onMediaAccessRejected
                * @param stopStream
                */
            requestMedia(video: boolean, onMediaAccessGranted?: Function, onMediaAccessRejected?: Function, stopStream?: boolean): void;
            /**
                * @hidden
                * @param callId
                * @param headers
                */
            hangupCall(callId: string, headers: {
                    [id: string]: string;
            }): void;
            /**
                * @hidden
                * @param destination
                * @param useVideo
                * @param headers
                * @param extraParams
                */
            callTo(destination: string, useVideo: boolean, headers: {
                    [id: string]: string;
            }, extraParams: {
                    [id: string]: string;
            }): void;
            /**
                * @hidden
                * @param callId
                */
            voicemailPromptFinished(callId: string): void;
            /**
                * @hidden
                * @param len
                */
            makeid(len: number): string;
            /**
                * @hidden
                * @param doMute
                */
            muteMicrophone(doMute: boolean): void;
            /**
                * @hidden
                * @param callId
                * @param digit
                */
            sendDigit(callId: string, digit: string): void;
            /**
                * @hidden
                * @param mic
                * @param net
                */
            startPreFlightCheck(mic?: boolean, net?: boolean): void;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
    }
}

declare module 'voximplant-websdk/EventHandlers' {
    import { LoginTokens, NetworkInfo, OperatorACDStatuses } from 'voximplant-websdk/Structures';
    import { Call } from 'voximplant-websdk/Call/Call';
    import { Endpoint } from 'voximplant-websdk/Call/EndPoints/Endpoint';
    import { MediaRenderer } from 'voximplant-websdk/Media/MediaRenderer';
    /**
        *
        * | Handler               | Event                         | Dispatch by               |
        * |-----------------------|-------------------------------|---------------------------|
        * |[AuthResult]           |[Events.AuthResult]            |[Client.login]<br>[Client.loginWithOneTimeKey]<br>[Client.loginWithToken]       |
        * |[AuthTokenResult]      |[Events.RefreshTokenResult]    |[Client.tokenRefresh]      |
        * |[ConnectionFailed]     |[Events.ConnectionFailed]      |[Client.connect]           |
        * |[IncomingCall]         |[Events.IncomingCall]          |None                       |
        * |[MicAccessResult]      |[Events.MicAccessResult]       |[Client.init]<br>[Client.attachRecordingDevice]<br>[Client.setVideoSettings] |
        * |[NetStatsReceived]     |[Events.NetStatsReceived]      |None                       |
        * |[SDKReady]             |[Events.SDKReady]              |[Client.init]              |
        * |[CallEvent]            |[CallEvents.ICECompleted]<br>[CallEvents.ICETimeout]<br>[CallEvents.ProgressToneStart]<br>[CallEvents.ProgressToneStop]<br>[CallEvents.TransferComplete]<br>[CallEvents.TransferFailed]|[Client.connect]<br>[Client.call]<br>[Call.answer]<br>[Client.transferCall]|
        * |[CallEventWithHeaders] |[CallEvents.Connected]         |[Client.call]<br>[Call.answer]|
        * |[Disconnected]         |[CallEvents.Disconnected]      |[Call.reject]<br>[Call.hangup]<br>Call disconnected from another side|
        * |[Failed]               |[CallEvents.Failed]            |[Client.call]              |
        * |[InfoReceived]         |[CallEvents.InfoReceived]      |[Call.sendInfo]            |
        * |[MessageReceived]      |[CallEvents.CallEvents]        |[Call.sendMessage]         |
        * |[MediaElementCreated]  |[CallEvents.MediaElementCreated]|New remote media stream received.|
        * |[Updated]              |[CallEvents.Updated]           |[Call.sendVideo]<br>[Call.setActive]<br>[Call.setVideoSettings]<br>[Call.shareScreen]<br>[Call.stopSharingScreen]<br>[Call.useAudioOutput]|
        */
    export namespace EventHandlers {
            interface AuthResult extends AuthTokenResult {
                    /**
                        *    Authorized user's display name
                        */
                    displayName?: string;
                    /**
                        *    This parameter is used to calculate hash parameter for
                        *    [Client.loginWithOneTimeKey] method. AuthResult with the key dispatched after
                        *    [Client.requestOneTimeLoginKey] method was called
                        */
                    key?: string;
            }
            interface AuthTokenResult {
                    /**
                        * @hidden
                        */
                    name: string;
                    /**
                        * Refresh token error code, possible values are:
                        *
                        * |Code|Description            |
                        * |----|-----------------------|
                        * |401 |invalid token          |
                        * |404 |invalid username       |
                        * |500 |internal error         |
                        * |701 |refresh token expired  |
                        */
                    code?: number;
                    /**
                        *    True in case of successful refresh, false - otherwise
                        */
                    result: boolean;
                    /**
                        * New tokens structure
                        */
                    tokens?: LoginTokens;
            }
            interface ConnectionFailed {
                    /**
                        *    Failure reason description
                        */
                    message: string;
            }
            interface IncomingCall {
                    /**
                        *    Incoming call instance.
                        *    See [Call] function for details
                        */
                    call: Call;
                    /**
                        *    Optional SIP headers received with the message
                        */
                    headers?: Object;
                    /**
                        * True if the caller initiated video call
                        */
                    video?: boolean;
            }
            interface MicAccessResult {
                    /**
                        *    True is access was allowed, false - otherwise
                        */
                    result: boolean;
                    /**
                        *    MediaStream object
                        */
                    stream: MediaStream;
            }
            interface NetStatsReceived {
                    /**
                        *    Network info object
                        */
                    stats: NetworkInfo;
            }
            interface SDKReady {
                    /**
                        *    SDK version
                        */
                    version: string;
            }
            interface CallEvent {
                    /**
                        *  Call that triggered the event
                        */
                    call: Call;
                    /**
                        * @hidden
                        */
                    name: string;
            }
            interface CallEventWithHeaders extends CallEvent {
                    /**
                        * Optional SIP headers are received with the message
                        */
                    headers?: Object;
            }
            interface Disconnected extends CallEventWithHeaders {
                    /**
                        * Optional disconnecting flags
                        */
                    params?: boolean;
            }
            interface Failed extends CallEventWithHeaders {
                    /**
                        * Call status code (i.e. 486)
                        *
                        * Most frequent status codes:
                        *
                        * |Code|Description                       |
                        * |----|----------------------------------|
                        * |486 |Destination number is busy        |
                        * |487 |Request terminated                |
                        * |603 |Call was rejected                 |
                        * |404 |Invalid number                    |
                        * |480 |Destination number is unavailable |
                        * |402 |Insufficient funds                |
                        */
                    code: number;
                    /**
                        *  Status message of a call failure (i.e. Busy Here)
                        */
                    reason: string;
            }
            interface InfoReceived extends CallEventWithHeaders {
                    /**
                        *  Content of the message
                        */
                    body: string;
                    /**
                        *  MIME type of INFO message
                        */
                    mimeType: string;
            }
            interface MessageReceived extends CallEvent {
                    /**
                        *  Content of the message
                        */
                    text: string;
            }
            interface MediaElementCreated extends CallEvent {
                    /**
                        *  Type of media
                        */
                    type: string;
                    /**
                        * Renderer element
                        */
                    element: HTMLMediaElement;
            }
            interface Updated extends CallEvent {
                    /**
                        * True in case of successful updating, false in other cases.
                        */
                    result: boolean;
            }
            /**
                * @hidden
                */
            interface UpdateFailed extends CallEvent {
                    /**
                        *  Most frequent status codes:
                        *
                        * |Code|Description                                |
                        * |----|-------------------------------------------|
                        * |10  |Timeout                                    |
                        * |11  |Trying to hold call in wrong state         |
                        * |12  |Trying change call in state UPDATING       |
                        * |13  |Media access rejected                      |
                        * |14  |Trying change call state to the same state |
                        * |20  |Server reject                              |
                        */
                    code: number;
            }
            /**
                * @hidden
                */
            interface LocalVideoStreamAdded extends MediaElementCreated {
                    videoStream: MediaStream;
            }
            interface SIPRegistrationResult {
                    /**
                        * @hidden
                        */
                    name: string;
                    /**
                        * SIP registration id
                        */
                    id: string;
                    /**
                        * SIP URI
                        */
                    sipuri: string;
                    /**
                        * Status code, if error
                        */
                    status?: number;
                    /**
                        * Reason, if error
                        */
                    reason?: string;
            }
            interface EndpointHandler {
                    /**
                        * @hidden
                        */
                    name: string;
                    call: Call;
                    endpoint: Endpoint;
            }
            interface EndpointMediaHandler extends EndpointHandler {
                    mediaRenderer: MediaRenderer;
            }
            /**
                * @hidden
                */
            interface ACDStatusEvent {
                    id: string;
                    status: OperatorACDStatuses;
            }
    }
}

declare module 'voximplant-websdk/Media/MediaRenderer' {
    /**
        * It is the wrapper for the HTMLMediaElement and its MediaStream.
        *   You can get this object on
        *   the [HardwareEvents.MediaRendererAdded] and
        *   [HardwareEvents.MediaRendererRemoved] for local media.
        *
        *   For remote media sources, you can get an instance
        *   of this object from [Endpoint] or
        *   [EndpointEvents.RemoteMediaAdded]
        *   or
        *   [EndpointEvents.RemoteMediaRemoved]
        */
    export class MediaRenderer {
            /**
                * A source stream sended from/to some Endpoint. The type of a stream is specified via the [kind] property.
                *
                * You can use the property for modifying and filtering source streams. E.g. for face masks and CV (computer vision).
                */
            stream: MediaStream;
            /**
                * Describe the tag and type of media, which are placed in this container.
                *   <ul>
                *   <li>Kind "audio" means &lt;audio&gt; HTML element and sound-only media stream</li>
                *   <li>Kind "video" means &lt;video&gt; HTML element and either video-only or audio plus video media stream</li>
                *   <li>Kind "sharing" the same as kind "video", but literally tell you "This is screen sharing"</li>
                *   </ul>
                */
            kind: 'audio' | 'video' | 'sharing';
            /**
                * @hidden
                */
            placeOnDom: boolean;
            /**
                * Source of the media stream. Set to "true" for the local streams, "false" for the remote streams.
                */
            isLocal: boolean;
            /**
                * HTML element where rendering is executed.
                */
            element: HTMLMediaElement;
            /**
                * Create new MediaRenderer for a local or a remote media stream
                * @param {MediaStream} stream
                * @param {"audio" | "video" | "sharing"} kind
                * @param {boolean} placeOnDom
                * @param {boolean} isLocal
                * @hidden
                */
            constructor(
            /**
                * A source stream sended from/to some Endpoint. The type of a stream is specified via the [kind] property.
                *
                * You can use the property for modifying and filtering source streams. E.g. for face masks and CV (computer vision).
                */
            stream: MediaStream, 
            /**
                * Describe the tag and type of media, which are placed in this container.
                *   <ul>
                *   <li>Kind "audio" means &lt;audio&gt; HTML element and sound-only media stream</li>
                *   <li>Kind "video" means &lt;video&gt; HTML element and either video-only or audio plus video media stream</li>
                *   <li>Kind "sharing" the same as kind "video", but literally tell you "This is screen sharing"</li>
                *   </ul>
                */
            kind: 'audio' | 'video' | 'sharing', 
            /**
                * @hidden
                */
            placeOnDom?: boolean, 
            /**
                * Source of the media stream. Set to "true" for the local streams, "false" for the remote streams.
                */
            isLocal?: boolean, deprecatedId?: string, isConference?: boolean);
            /**
                * Unique ID of MediaRender
                */
            readonly id: string;
            /**
                * @hidden
                */
            renderDefault(): void;
            /**
                * Render (display) current instance of MediaRenderer to the HTMLElement in the DOM tree. If the container paramater is not specified, the method will append rendering to the body element.
                * The method allows to render manually in cases of:
                * 1. Default rendering was turned off. If you subscribe to the [EndpointEvents.RemoteMediaAdded] event, Web SDK will no longer render remote audio/video stream automatically so you have to call this method with optional __container__ parameter.
                * 2. default rendering is active, but you want to change rendering container. Call the method with the specified HTMLElement.
                * @param {HTMLElement} container place for rendering.
                */
            render(container?: HTMLElement): void;
            /**
                * Destroy current unit and free resources.
                * @hidden
                */
            clear(): void;
            /**
                * Set current MediaRenderer output volume. The range is from 0 to 1.
                * @param {number} level
                */
            setVolume(level: number): void;
            /**
                * Set the output audio device for current MediaRenderer. ID can be retrieved via the [AudioDeviceManager.getOutputDevices] method.
                * @param {string} id`
                */
            useAudioOutput(id: string): void;
            /**
                * Run when current MediaRenderer unit was destroyed
                * @hidden
                */
            onDestroy: Function;
            /**
                * Run when current MediaRenderer unit will destroyed
                * @hidden
                */
            onBeforeDestroy: Function;
    }
}

declare module 'voximplant-websdk/Messenger/MessengerEventsCallbacks/index' {
    export { ConversationEvent } from 'voximplant-websdk/Messenger/MessengerEventsCallbacks/ConversationEvent';
    export { ConversationServiceEvent } from 'voximplant-websdk/Messenger/MessengerEventsCallbacks/ConversationServiceEvent';
    export { ErrorEvent } from 'voximplant-websdk/Messenger/MessengerEventsCallbacks/ErrorEvent';
    export { MessageEvent } from 'voximplant-websdk/Messenger/MessengerEventsCallbacks/MessageEvent';
    export { MessengerEvent } from 'voximplant-websdk/Messenger/MessengerEventsCallbacks/MessengerEvent';
    export { RetransmitEvent } from 'voximplant-websdk/Messenger/MessengerEventsCallbacks/RetransmitEvent';
    export { StatusEvent } from 'voximplant-websdk/Messenger/MessengerEventsCallbacks/StatusEvent';
    export { SubscriptionEvent } from 'voximplant-websdk/Messenger/MessengerEventsCallbacks/SubscriptionEvent';
    export { UserEvent } from 'voximplant-websdk/Messenger/MessengerEventsCallbacks/UserEvent';
}

declare module 'voximplant-websdk/Messenger/src' {
    export { Conversation } from 'voximplant-websdk/Messenger/src/Conversation';
    export { Message } from 'voximplant-websdk/Messenger/src/Message';
    export { Messenger } from 'voximplant-websdk/Messenger/src/Messenger';
    export * from 'voximplant-websdk/Messenger/src/Structures';
}

declare module 'voximplant-websdk/Call/EndpointListDescription' {
    /**
        * @hidden
        */
    export interface EndpointListDescription {
            endpoints: {
                    [id: string]: EndpointDescription;
            };
    }
    /**
        * @hidden
        */
    export interface EndpointDescription {
            place: number;
            type: 'call' | 'player';
            tracks: {
                    [id: string]: 'audio' | 'video' | 'sharing';
            };
    }
    /**
        * @hidden
        */
    export interface EndpointInfoData {
            id: string;
            place: number;
            username: string;
            displayName: string;
            sipURI: string;
    }
}

declare module 'voximplant-websdk/Types' {
    /**
        * @hidden
        */
    export enum BrowserMode {
            Firefox = 0,
            Chrome = 1
    }
    /**
        * @hidden
        */
    export enum TrackType {
            audio,
            video,
            sharing
    }
    /**
        * Call related errors.
        * @hidden
        */
    export enum CallError {
            /**
                * The call is already in requested state
                */
            ALREADY_IN_THIS_STATE = 0,
            /**
                * Requested functionality is disabled
                */
            FUNCTIONALITY_IS_DISABLED = 1,
            /**
                * Operation is incorrect, f.ex.
                */
            INCORRECT_OPERATION = 2,
            /**
                * Internal error occurred
                */
            INTERNAL_ERROR = 3,
            /**
                * Operation can't be performed due to the call is on hold.
                */
            MEDIA_IS_ON_HOLD = 4,
            /**
                * Operation is rejected
                */
            REJECTED = 5,
            /**
                * Operation is not completed in time
                */
            TIMEOUT = 6
    }
}

declare module 'voximplant-websdk/Hardware/src' {
    /**
        * @hidden
        */
    export { AudioDeviceManager } from 'voximplant-websdk/Hardware/src/AudioDeviceManager';
    /**
        * @hidden
        */
    export { AudioParams } from 'voximplant-websdk/Hardware/src/AudioParams';
    /**
        * @hidden
        */
    export { CameraManager } from 'voximplant-websdk/Hardware/src/CameraManager';
    /**
        * @hidden
        */
    export { CameraParams } from 'voximplant-websdk/Hardware/src/CameraParams';
    /**
        * @hidden
        */
    export { SharingStream } from 'voximplant-websdk/Hardware/src/SharingStream';
    /**
        * @hidden
        */
    export { StreamManager } from 'voximplant-websdk/Hardware/src/StreamManager';
    /**
        * @hidden
        */
    export { IOSCacheManager } from 'voximplant-websdk/Hardware/src/IOSCacheManager';
}

declare module 'voximplant-websdk/PeerConnection/PeerConnection' {
    import { Logger } from 'voximplant-websdk/Logger';
    import { Call } from 'voximplant-websdk/Call/Call';
    import { VideoFlags } from 'voximplant-websdk/Structures';
    import { TrackType } from 'voximplant-websdk/Types';
    import { ReInviteQ } from 'voximplant-websdk/PeerConnection/ReInviteQ';
    import { EventHandlers } from 'voximplant-websdk/EventHandlers';
    import Updated = EventHandlers.Updated;
    /**
        * @hidden
        */
    export enum PeerConnectionState {
            IDLE = 0,
            REMOTEOFFER = 1,
            LOCALOFFER = 2,
            ESTABLISHING = 3,
            ESTABLISHED = 4,
            CLOSED = 5
    }
    /**
        * @hidden
        */
    export enum PeerConnectionMode {
            CLIENT_SERVER_V1 = 0,
            P2P = 1,
            CONFERENCE = 2
    }
    /**
        * Peer connection wrapper. Will have implementations for WebRTC/ORTC
        * @hidden
        */
    export abstract class PeerConnection {
            protected id: string;
            protected mode: PeerConnectionMode;
            protected videoEnabled: VideoFlags;
            protected _localStream: MediaStream;
            protected log: Logger;
            protected state: PeerConnectionState;
            protected _call: Call;
            protected pendingCandidates: any;
            protected candidateSendTimer: any;
            protected canSendCandidates: boolean;
            protected reInviteQ: ReInviteQ;
            protected sinkId: any;
            /**
                * @hidden
                * @param state
                */
            protected onHold: boolean;
            protected _canReInvite: {
                    (): boolean;
            };
            protected muteMicState: boolean;
            protected renegotiationInProgress: boolean;
            constructor(id: string, mode: PeerConnectionMode, videoEnabled: VideoFlags);
            protected _remoteStreams: Array<MediaStream>;
            readonly remoteStreams: MediaStream[];
            abstract _hdnFRSPrep(): void;
            abstract hasLocalAudio(): boolean;
            abstract hasLocalVideo(): boolean;
            abstract enableVideo(flag: boolean): void;
            abstract getTransceivers(): any;
            abstract getRemoteDescription(): string;
            abstract _fixFFSoundBug(): void;
            getId(): string;
            getState(): PeerConnectionState;
            processRemoteAnswer(headers: {
                    [id: string]: string;
            }, sdp: string): Promise<void>;
            getLocalOffer(): Promise<RTCSessionDescription>;
            getLocalAnswer(): Promise<RTCSessionDescription>;
            processRemoteOffer(sdp: string): Promise<string>;
            close(): void;
            addRemoteCandidate(candidate: string, mLineIndex: number): Promise<void>;
            handleReinvite(headers: {
                    [id: string]: string;
            }, sdp: string, hasVideo: boolean): Promise<void>;
            addCandidateToSend(attrString: any, mLineIndex: any): void;
            canStartSendingCandidates(): void;
            sendDTMF(key: string): void;
            setVideoEnabled(newVal: VideoFlags): void;
            setVideoFlags(newFlags: VideoFlags): void;
            /**
                * Get sdp audio/video directions from sdp
                * @hidden
                */
            getDirections(): Object;
            /**
                * @hidden
                * @param state
                */
            setHoldKey(state: any): void;
            getTrackKind(): {
                    [id: string]: TrackType;
            };
            sendMedia(audio: boolean, video: boolean): Promise<EventHandlers.Updated>;
            /**
                * Hold/Unhold action for protocol v3 (Fully implement RFC 4566
                * @param newState
                */
            hold(newState: boolean): Promise<EventHandlers.Updated>;
            hdnFRS(): Promise<EventHandlers.Updated>;
            abstract _hdnFRS(): void;
            muteMicrophone(newState: boolean): void;
            restoreMute(): void;
            addCustomMedia(stream: MediaStream): Promise<Updated>;
            /**
                * @hidden
                * @param {MediaStream} stream
                */
            fastAddCustomMedia(stream: MediaStream): void;
            /**
                * @hidden
                * @param {MediaStream} stream
                */
            fastRemoveCustomMedia(stream: MediaStream): void;
            removeCustomMedia(stream: MediaStream): Promise<void>;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
            protected abstract _processRemoteAnswer(headers: {
                    [id: string]: string;
            }, sdp: string): Promise<void>;
            protected abstract _getLocalOffer(): Promise<RTCSessionDescription>;
            protected abstract _getLocalAnswer(): Promise<RTCSessionDescription>;
            protected abstract _processRemoteOffer(sdp: string): Promise<string>;
            protected abstract _close(): any;
            protected abstract _addRemoteCandidate(candidate: string, mLineIndex: number): Promise<void>;
            protected abstract _sendDTMF(key: string, duration: number, gap: number): void;
            protected abstract _getDirections(): Object;
            protected abstract _getStreamActivity(): Object;
            protected abstract _handleReinvite(headers: {
                    [id: string]: string;
            }, sdp: string, hasVideo: boolean): Promise<void>;
            protected setState(st: PeerConnectionState): void;
            protected sendLocalCandidateToPeer(cand: string, mLineIndex: number): void;
            protected abstract _hold(newState: boolean): void;
            protected abstract _addCustomMedia(stream: MediaStream): void;
            protected abstract _removeCustomMedia(stream: MediaStream): void;
            abstract getConfiguration(): RTCConfiguration;
            abstract setConfiguration(config: RTCConfiguration): any;
    }
}

declare module 'voximplant-websdk/Call/CallManager' {
    import { Call } from 'voximplant-websdk/Call/Call';
    import { VoxSignalingHandler } from 'voximplant-websdk/Signaling/VoxSignalingHandler';
    import { CallSettings, VideoSettings } from 'voximplant-websdk/Structures';
    /**
        * Implenets signaling protocol and local call management'
        * Singleton
        * All call manipulation MUST be there
        * @hidden
        */
    export class CallManager implements VoxSignalingHandler {
            rtcStatsCollectionInterval: number;
            protocolVersion: string;
            _h264first: boolean;
            constructor();
            readonly calls: {
                    [id: string]: Call;
            };
            /**
                * Get active call count
                * @hidden
                * @returns {number}
                */
            readonly numCalls: number;
            static get(): CallManager;
            /**
                * Remove all non X- headers
                * @param headers
                * @returns {{}}
                */
            static cleanHeaders(headers: {
                    [id: string]: string;
            }): {
                    [id: string]: string;
            };
            /**
                * Place an outgoing call
                * @param {string} number Number to place call
                * @param {object} headers Additional headers
                * @param {boolean} video Initial state of video - enabled/disabled
                * @param {object} extraParams DEPRECATED
                */
            call(sets: CallSettings): Call;
            callConference(sets: CallSettings): Call;
            /**
                * Check if sdp have video section with send flow
                * @param sdp
                * @returns {boolean}
                */
            isSDPHasVideo(sdp: any): boolean;
            handleConnectionFailed(id: string, code: number, reason: string, headers: {
                    [id: string]: string;
            }): void;
            onSignalingConnected(): void;
            onSignalingClosed(): void;
            onSignalingConnectionFailed(errorMessage: string): void;
            onMediaConnectionFailed(): void;
            transferCall(call1: Call, call2: Call): void;
            /**
                * Fx for backward compatibility with hidden Fx Client.removeCall
                * @param call_id
                */
            removeCall(call_id: string): void;
            setProtocolVersion(ver: string): void;
            setAllCallsVolume(level: number): void;
            useVideoSource(id: string): Promise<void>;
            setVideoSettings(settings: VideoSettings): Promise<void>;
            useAudioSource(id: string): Promise<void>;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
            iceServers: {
                    [callId: string]: RTCIceServer[];
            };
            onICEResult(id: string, result: boolean, config?: any): void;
    }
}

declare module 'voximplant-websdk/PeerConnection/SDP/Interfaces' {
    /**
        * Parsed sections with parsed codecs
        * @hidden
        */
    export interface CodecSorterCodecList {
            /**
                * part of sdp before media section
                */
            prefix: string;
            /**
                * Media sections
                */
            sections: Array<CodecSorterSection>;
    }
    /**
        * Parsed section of codec
        * @hidden
        */
    export interface CodecSorterSection {
            /**
                * kind of media section
                * @see https://tools.ietf.org/html/rfc4566#section-5.14
                */
            kind: any;
            /**
                * First line without codec order
                */
            firstLine: string;
            /**
                * Part of media section before codec
                */
            prefix: string;
            /**
                * List of codec parsed by /r/n point
                */
            codec: Array<Array<string>>;
            /**
                * Part of media section after codec definition
                */
            sufix: string;
    }
    /**
        * Object holding media section for sorting by end user
        * @example
        *  //Google Chrome 54
        *  codecList = {
        *    "sections":[
        *      {
        *        "kind":"audio",
        *        "codec":
        *          [
        *            "opus/48000/2",
        *            "ISAC/16000",
        *            "ISAC/32000",
        *            "G722/8000",
        *            "PCMU/8000",
        *            "PCMA/8000",
        *            "CN/32000",
        *            "CN/16000",
        *            "CN/8000",
        *            "telephone-event/8000"
        *          ]
        *      },
        *      {
        *        "kind":"video",
        *        "codec":
        *          [
        *            "VP8/90000",
        *            "VP9/90000",
        *            "H264/90000",
        *            "red/90000",
        *            "ulpfec/90000",
        *            "rtx/90000",
        *            "rtx/90000",
        *            "rtx/90000",
        *            "rtx/90000"
        *          ]
        *      }
        *    ]
        *  }
        */
    export interface CodecSorterUserCodecList {
            /**
                * List of sections for end user
                */
            sections: CodecSorterUserSections[];
    }
    /**
        *  Description of one media section
        *  @example
        *   section = {
        *    "kind":"audio",
        *    "codec":
        *      [
        *        "opus/48000/2",
        *        "ISAC/16000",
        *        "ISAC/32000",
        *        "G722/8000",
        *        "PCMU/8000",
        *        "PCMA/8000",
        *        "CN/32000",
        *        "CN/16000",
        *        "CN/8000",
        *        "telephone-event/8000"
        *      ]
        *   }
        */
    export interface CodecSorterUserSections {
            /**
                * kind of media - list accepted media shorted for "audio" and "video"
                */
            kind: 'audio' | 'video';
            /**
                * list of payload description for end user
                */
            codec: Array<string>;
    }
}

declare module 'voximplant-websdk/Messenger/MessengerEventsCallbacks/ConversationEvent' {
    import { MessengerEvent } from 'voximplant-websdk/Messenger/MessengerEventsCallbacks/MessengerEvent';
    import Messaging from 'voximplant-websdk/Messenger/index';
    /**
        * @hidden
        */
    export interface ConversationEvent extends MessengerEvent {
            /**
                * Get conversation information.
                */
            conversation: Messaging.Conversation;
            /**
                * Get sequence number for this event.
                */
            sequence: number;
    }
}

declare module 'voximplant-websdk/Messenger/MessengerEventsCallbacks/ConversationServiceEvent' {
    import { MessengerEvent } from 'voximplant-websdk/Messenger/MessengerEventsCallbacks/MessengerEvent';
    /**
        * @hidden
        */
    export interface ConversationServiceEvent extends MessengerEvent {
            /**
                * Get conversation UUID associated with this event.
                */
            conversationUUID: string;
            /**
                * Get UNIX timestamp that specifies the time a method was called.
                */
            timestamp: number;
            /**
                * Get sequence number for this event.
                */
            sequence: number;
    }
}

declare module 'voximplant-websdk/Messenger/MessengerEventsCallbacks/ErrorEvent' {
    import { MessengerEvent } from 'voximplant-websdk/Messenger/MessengerEventsCallbacks/MessengerEvent';
    import Messaging from 'voximplant-websdk/Messenger/index';
    /**
        * @hidden
        */
    export interface ErrorEvent extends MessengerEvent {
            /**
                * Messaging error code
                */
            code: Messaging.MessengerError;
            /**
                * Human-readable error description.
                */
            description: string;
    }
}

declare module 'voximplant-websdk/Messenger/MessengerEventsCallbacks/MessageEvent' {
    import { MessengerEvent } from 'voximplant-websdk/Messenger/MessengerEventsCallbacks/MessengerEvent';
    import Messaging from 'voximplant-websdk/Messenger/index';
    /**
        * @hidden
        */
    export interface MessageEvent extends MessengerEvent {
            /**
                * Message object
                */
            message: Messaging.Message;
            /**
                * Sequence number for this event
                */
            sequence: number;
    }
}

declare module 'voximplant-websdk/Messenger/MessengerEventsCallbacks/MessengerEvent' {
    import Messaging from 'voximplant-websdk/Messenger/index';
    /**
        * @hidden
        */
    export interface MessengerEvent {
            /**
                * Get action that is the reason this event was triggered
                */
            messengerAction: Messaging.MessengerAction;
            /**
                * Get messenger event type if this messenger event was retransmitted.
                */
            messengerEventType: Messaging.MessengerEvents;
            /**
                * Get Voximplant user identifier, ex 'username@appname.accname', for the user that initiated the event.
                */
            userId: string;
    }
}

declare module 'voximplant-websdk/Messenger/MessengerEventsCallbacks/RetransmitEvent' {
    import { MessengerEvent } from 'voximplant-websdk/Messenger/MessengerEventsCallbacks/MessengerEvent';
    import { Messaging } from 'voximplant-websdk/Messenger/index';
    /**
        * @hidden
        */
    export interface RetransmitEvent extends MessengerEvent {
            /**
                * Event is triggered after [Conversation.retransmitEvents] method is called on some conversation for this SDK instance.
                */
            events: Array<Messaging.RetransmittedEvent>;
    }
}

declare module 'voximplant-websdk/Messenger/MessengerEventsCallbacks/StatusEvent' {
    import { Messaging } from 'voximplant-websdk/Messenger/index';
    import { MessengerEvent } from 'voximplant-websdk/Messenger/MessengerEventsCallbacks/MessengerEvent';
    /**
        * @hidden
        */
    export interface StatusEvent extends MessengerEvent {
            /**
                * User presence description
                */
            userStatus: Messaging.UserStatus;
    }
}

declare module 'voximplant-websdk/Messenger/MessengerEventsCallbacks/SubscriptionEvent' {
    import { MessengerEvent } from 'voximplant-websdk/Messenger/MessengerEventsCallbacks/MessengerEvent';
    /**
        * @hidden
        */
    export interface SubscriptionEvent extends MessengerEvent {
            /**
                * List of full Voximplant user identifiers (ex 'username@appname.accname') for the subscription.
                */
            users: Array<string>;
    }
}

declare module 'voximplant-websdk/Messenger/MessengerEventsCallbacks/UserEvent' {
    import { MessengerEvent } from 'voximplant-websdk/Messenger/MessengerEventsCallbacks/MessengerEvent';
    import { Messaging } from 'voximplant-websdk/Messenger/index';
    /**
        * @hidden
        */
    export interface UserEvent extends MessengerEvent {
            /**
                * User presence description
                */
            user: Messaging.User;
    }
}

declare module 'voximplant-websdk/Messenger/src/Conversation' {
    import { ConversationParticipant, MsgConversation, Payload, SerializedConversation } from 'voximplant-websdk/Messenger/src/Structures';
    import { Message } from 'voximplant-websdk/Messenger/src/Message';
    import Messaging from 'voximplant-websdk/Messenger/index';
    /**
        * @hidden
        */
    export class Conversation {
            /**
                * @hidden
                */
            constructor(participants: Array<ConversationParticipant>, distinct?: boolean, publicJoin?: boolean, customData?: any, moderators?: Array<string>);
            /**
                * Universally unique identifier of current conversation. Used in methods like 'get', 'remove' etc.
                * @returns {string}
                */
            readonly uuid: string;
            /**
                * Conversation moderator names list.
                */
            readonly moderators: Array<string>;
            readonly createdAt: string;
            /**
             * Sets current conversation title. Note that setting this property does not send changes to the server. Use the 'update' to send all changes at once or 'setTitle' to update and set the title.
             * @param value
             */
            title: string;
            /**
             * If two conversations are created with same set of users and moderators and both have 'distinct' flag, second create call will fail with the UUID of conversation already created. Note that changing users or moderators list will clear 'distinct' flag.
             * Note that setting this property does not send changes to the server. Use the 'update' to send all changes at once or 'setDistinct' to update and set the distinct flag.
             * @param value
             */
            distinct: boolean;
            /**
             * If set to 'true', anyone can join conversation by UUID. Note that setting this property does not send changes to the server. Use the 'update' to send all changes at once or 'setPublicJoin' to update and set the public join flag.
             * @param value
             */
            publicJoin: boolean;
            /**
                * Conversation participants list alongside with their rights.
                */
            readonly participants: Array<ConversationParticipant>;
            /**
             * JavaScript object with custom data, up to 5kb. Note that setting this property does not send changes to the server. Use the 'update' to send all changes at once or 'setCustomData' to update and set the custom data.
             * @param value
             */
            customData: any;
            /**
                * Last event sequence for this conversation. Used with 'lastRead' to display unread messages and events.
                */
            readonly lastSeq: any;
            /**
                * UNIX timestamp integer that specifies the time of the last event in the conversation. It's same as 'Date.now()' divided by 1000.
                */
            readonly lastUpdate: any;
            /**
                * Returns sequence of last event that was read by user. Used to display unread messages, events etc.
                * @returns {any}
                */
            readonly lastRead: any;
            /**
                * @hidden
                * @return {boolean}
                */
            readonly uberConversation: boolean;
            /**
                * Create conversation from buss
                * @param busConversation
                * @hidden
                */
            static _createFromBus(busConversation: MsgConversation, seq: number): Conversation;
            /**
                * Restore conversation from cache
                * @param cacheConversation
                * @returns {Conversation}
                * @hidden
                */
            static createFromCache(cacheConversation: SerializedConversation): Conversation;
            /**
                *
                * @hidden
                */
            _getPayload(): any;
            /**
                *
                * @hidden
                */
            _getSimplePayload(): any;
            /**
                * Generate UUID for new conversation
                *
                * @hidden
                */
            _createUUID(): void;
            /**
                * Serialize conversation so it can be stored into some storage (like IndexedDB) and later restored via [Messenger.createConversationFromCache]
                * @returns {SerializedConversation}
                */
            toCache(): SerializedConversation;
            sendMessage(message: string, payload?: Array<Payload>): Message;
            /**
                * Calling this method will inform backend that user is typing some text. Calls within 10s interval from the last call are discarded.
                * @returns {boolean} 'true' is message was actually sent, 'false' if it was discarded.
                */
            typing(): boolean;
            /**
                * Mark the event with the specified sequence as 'read'. This affects 'lastRead' and is used to display unread messages and events. Triggers the [MessengerEvents.Read] event for all messenger objects on all connected clients, including this one.
                * @param seq
                */
            markAsRead(seq: number): void;
            /**
                * Mark event as handled by current logged-in device. If single user is logged in on multiple devices, this can be used to display delivery status by subscribing to the [MessengerEvents.Delivered] event.
                * @param seq
                */
            markAsDelivered(seq: number): void;
            /**
                * Remove current conversation. All participants, including this one, will receive the [MessengerEvents.RemoveConversation] event.
                */
            remove(): void;
            /**
                * Send conversation changes to the server: title, public join flag, distinct flag and custom data. Used to send all changes modified via properties. Changes via 'setTitle', 'setPublicJoin' etc are sent instantly.
                */
            update(): void;
            /**
                * Set the conversation title and send changes to the server.
                */
            setTitle(title: string): void;
            /**
                * Set the public join flag and send changes to the server.
                */
            setPublicJoin(publicJoin: boolean): void;
            /**
                * Set the distinct flag and send changes to the server.
                */
            setDistinct(distinct: boolean): void;
            /**
                * Set the JS object custom data and send changes to the server.
                */
            setCustomData(customData: any): void;
            /**
                * Add new participants to the conversation.
                * Duplicated users are ignored.
                * Will fail if any user does not exist.
                * Triggers the [MessengerEvents.EditConversation]
                * event for all messenger objects on all clients, including this one.
                * @param participants
                * @returns {Promise<EditConversation>|Promise}
                */
            addParticipants(participants: Array<ConversationParticipant>): Promise<Messaging.MessengerEventsCallbacks.ConversationEvent>;
            /**
                * Change access rights for the existing participants.
                * This function doesn't apply any changes to the participant list.
                * Use the [Conversation.addParticipants] or [Conversation.removeParticipants] methods instead.
                * Triggers the [MessengerEvents.EditConversation]
                * event for all messenger objects on all clients, including this one.
                * @param participants
                * @returns {Promise<EditConversation>|Promise}
                */
            editParticipants(participants: Array<ConversationParticipant>): Promise<Messaging.MessengerEventsCallbacks.ConversationEvent>;
            /**
                * Remove participants from the conversation.
                * Duplicated users are ignored.
                * Will fail if any user does not exist.
                * Triggers the [MessengerEvents.EditConversation]
                * event for all messenger objects on all clients, including this one.
                * @param participants
                * @returns {Promise<EditConversation>|Promise}
                */
            removeParticipants(participants: Array<ConversationParticipant>): Promise<Messaging.MessengerEventsCallbacks.ConversationEvent>;
            /**
                * Add new moderators to the conversation.
                * Duplicated users are ignored.
                * Will fail if any user does not exist.
                * Triggers the [MessengerEvents.EditConversation]
                * event for all messenger objects on all clients, including this one.
                * @param participants
                * @returns {Promise<EditConversation>|Promise}
                */
            addModerators(moderators: Array<string>): Promise<Messaging.MessengerEventsCallbacks.ConversationEvent>;
            /**
                * Remove moderators from the conversation.
                * Duplicated users are ignored.
                * Will fail if any user does not exist.
                * Triggers the [MessengerEvents.EditConversation]
                * event for all messenger objects on all clients, including this one.
                * @param participants
                * @returns {Promise<EditConversation>|Promise}
                */
            removeModerators(moderators: Array<string>): Promise<Messaging.MessengerEventsCallbacks.ConversationEvent>;
            /**
                * Request events in the specified sequence range to be sent from server into this client.
                * Maximum 100 events can be requested by one method call.
                * Sequence numbers of the resulting events may contain 'holes' due to the server-side implementation.
                * Method is used to get history or get missed events in case of network disconnect.
                * Please note that server will not push any events that was missed due to the client being offline.
                * Client should use this method to request all events based on the last event sequence received from the server and last event sequence saved locally (if any).
                * @param eventsFrom first event in range sequence, inclusive
                * @param eventsTo last event in range sequence, inclusive
                */
            retransmitEvents(eventsFrom: number, eventsTo: number): Promise<Messaging.MessengerEventsCallbacks.RetransmitEvent>;
            /**
                * @hidden
                * @param newSeq
                */
            updateSeq(newSeq: number): void;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
    }
}

declare module 'voximplant-websdk/Messenger/src/Message' {
    import { MsgMessage, Payload, SerializedMessage } from 'voximplant-websdk/Messenger/src/Structures';
    import { Conversation } from 'voximplant-websdk/Messenger/src/Conversation';
    /**
        * @hidden
        */
    export class Message {
            /**
                * @hidden
                * @param {string} message
                * @param {Array<Payload>} payload
                */
            constructor(message: string, payload: Array<Payload>);
            /**
                * Universally unique identifier of message. Can be used on client side for housekeeping.
                * @returns {string}
                */
            readonly uuid: string;
            /**
                * UUID of the conversation this message belongs to.
                */
            readonly conversation: string;
            /**
                * Message text.
                */
            text: string;
            /**
                * Array of 'Payload' objects associated with the message.
                */
            payload: Array<Payload>;
            /**
                * Message sequence number.
                */
            readonly seq: number;
            readonly sender: string;
            /**
                * Create message from bus
                * @param busMessage
                * @param seq
                * @hidden
                */
            static _createFromBus(busMessage: MsgMessage, seq: number): Message;
            /**
                * @hidden
                * @param cacheMessage
                * @returns {Message}
                */
            static createFromCache(cacheMessage: SerializedMessage): Message;
            /**
                * @hidden
                * @param conversation
                */
            sendTo(conversation: Conversation): void;
            /**
                * @hidden
                * @returns {{uuid: string, text: string, conversation: string}}
                */
            getPayload(): any;
            /**
                * Sends text and payload changes to the server.
                */
            update(): void;
            /**
                * Remove the message.
                * Triggers the [MessengerEvents.RemoveMessage]
                * event for all messenger objects on all clients, including this one.
                */
            remove(): void;
            /**
                * Serialize message so it can be stored into some storage (like IndexedDB) and later restored via [Messenger.createMessageFromCache]
                */
            toCache(): SerializedMessage;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
    }
}

declare module 'voximplant-websdk/Messenger/src/Messenger' {
    import { ConversationParticipant, SerializedConversation, SerializedMessage } from 'voximplant-websdk/Messenger/src/Structures';
    import { Conversation } from 'voximplant-websdk/Messenger/src/Conversation';
    import { Message } from 'voximplant-websdk/Messenger/src/Message';
    import Messaging from 'voximplant-websdk/Messenger/index';
    /**
        * @hidden
        */
    export class Messenger {
            /**
                * @hidden
                */
            constructor();
            /**
                * @hidden
                */
            static getInstance(): Messenger;
            /**
                * Create a new conversation.
                * Triggers either the [MessengerEvents.Error] or [MessengerEvents.CreateConversation] event on all connected clients that are mentioned in the 'participants' array.
                * @see Messengerevents.CreateConversation
                * @see Messengerevents.Error
                * @param participants Array of participants alongside with access rights params
                * @param moderators Array of moderators
                * @param distinct If two conversations are created with same set of users and moderators and both have 'distinct' flag, second creation of conversation (with the same participants) will fail with the UUID of conversation already created. Note that changing users or moderators list will clear 'distinct' flag.
                * @param enablePublicJoin The feature allows users from any Voximplant account to join the conversation using its uuid.
                * @param customData JavaScript object with custom data, up to 5kb. Note that setting this property does not send changes to the server. Use [Conversation.update] to send all changes at once or [Conversation.setCustomData] to update and set the custom data.
                * @param title conversation title
                */
            createConversation(participants: Array<ConversationParticipant>, title?: string, distinct?: boolean, enablePublicJoin?: boolean, customData?: any, moderators?: Array<string>): void;
            /**
                * Get conversation by it's UUID.The method triggers the [MessengerEvents.GetConversation] or [MessengerEvents.Error] event.
                * The handler function receives the [EventHandlers.ConversationEvent] object with UUID etc.
                * @see [MessengerEvents.GetConversation]
                * @see [MessengerEvents.Error]
                * @param uuid
                */
            getConversation(uuid: string): void;
            /**
                * Get multiple conversations by array of UUIDs. Maximum 30 conversation. Note that calling this method will result in *multiple* 'getConversation' events.
                * @see [MessengerEvents.GetConversation]
                * @see [MessengerEvents.Error]
                * @param conversations Array of UUIDs
                * @returns {Array<Conversation>}
                */
            getConversations(conversations: Array<string>): void;
            /**
                * @hidden
                */
            getRawConversations(conversations: Array<string>): void;
            /**
                * Remove the conversation specified by the UUID
                * @see [MessengerEvents.RemoveConversation]
                * @see [MessengerEvents.Error]
                * @param uuid Universally Unique Identifier of the conversation
                */
            removeConversation(uuid: string): void;
            /**
                * Join current user to the conversation specified by the UUID
                * @see [MessengerEvents.EditConversation]
                * @see [MessengerEvents.Error]
                * @param uuid Universally Unique Identifier of the conversation
                */
            joinConversation(uuid: string): void;
            /**
                * Leave current user from the conversation specified by the UUID
                * @see [MessengerEvents.EditConversation]
                * @see [MessengerEvents.Error]
                * @param uuid  Universally Unique Identifier of the conversation
                */
            leaveConversation(uuid: string): void;
            /**
                * Get user information for the user specified by the full Voximplant user identifier, ex 'username@appname.accname'
                * @see [MessengerEvents.GetUser]
                * @see [MessengerEvents.Error]
                * @param user_id User identifier
                */
            getUser(user_id: string): Promise<Messaging.MessengerEventsCallbacks.UserEvent>;
            /**
                * Get the full Voximplant user identifier, ex 'username@appname.accname', for the current user
                * @returns {string} current user short identifier
                */
            getMe(): string;
            /**
                * Edit current user information.
                * @see [MessengerEvents.EditUser]
                * @see [MessengerEvents.Error]
                * @param custom_data Public custom data available for all users
                * @param private_custom_data Private custom data available only to the user themselves.
                */
            editUser(customData?: Object, privateCustomData?: Object): void;
            /**
                * Get user information for the users specified by the array of the full Voximplant user identifiers, ex 'username@appname.accname'
                * @see [MessengerEvents.GetUser]
                * @see [MessengerEvents.Error]
                * @param users List of user identifiers
                */
            getUsers(users: Array<string>): void;
            /**
                * Register handler for the specified event
                * @hidden
                * @deprecated
                * @param event Event identifier
                * @param handler JavaScript function that will be called when the specified event is triggered. Please note that function is called without 'this' binding.
                */
            addEventListener(event: Messaging.MessengerEvents, handler: Function): void;
            /**
                * Remove handler for the specified event
                * @hidden
                * @deprecated
                * @param event Event identifier
                * @param handler Reference to the JavaScript function to remove from event listeners. If not specified, removes all event listeners from the specified event.
                */
            removeEventListener(event: Messaging.MessengerEvents, handler?: Function): void;
            /**
                * @hidden
                * @param event
                * @param payload
                */
            _dispatchEvent(event: Messaging.MessengerEvents, payload: any): void;
            /**
                * Register a handler for the specified event. The method is a shorter equivalent for *addEventListener*. One event can have more than one handler; handlers are executed in order of registration.
                * Use the [Messenger.off] method to delete a handler.
                * @param event
                * @param handler
                */
            on(event: Messaging.MessengerEvents, handler: Function): void;
            /**
                * Remove a handler for the specified event. The method is a shorter equivalent for *removeEventListener*. If a number of events has the same function as a handler, the method can be called multiple times with the same handler argument.
                * @param event
                * @param handler
                */
            off(event: Messaging.MessengerEvents, handler?: Function): void;
            /**
                * Add new promice for awaiting.
                * @param event
                * @param resolve
                * @param reject
                * @hidden
                */
            _registerPromise(event: Messaging.MessengerEvents, resolve: Function, reject: Function): void;
            /**
                * Restore conversation from cache that is previously created by the 'toCache' method.
                * @param cacheConversation JavaScript object for the serialized conversation
                * @returns {Conversation}
                */
            createConversationFromCache(cacheConversation: SerializedConversation): Conversation;
            /**
                * Restore message from cache that is previously created by the 'toCache' method.
                * @param cacheMessage JavaScript object for the serialized conversation
                * @returns {Message}
                */
            createMessageFromCache(cacheMessage: SerializedMessage): Message;
            /**
                * Subscribe for user information change and presence status change; a method call triggers the [MessengerEvents.Subscribe] event.
                * @see [MessengerEvents.Subscribe]
                * @see [MessengerEvents.Error]
                * @param users List of full Voximplant user identifiers, ex 'username@appname.accname'
                */
            subscribe(users: Array<string>): void;
            /**
                * Unsubscribe for user information change and presence status change; a method call triggers the [MessengerEvents.Unsubscribe] event.
                * @see [MessengerEvents.Unsubscribe]
                * @see [MessengerEvents.Error]
                * @param users List of full Voximplant user identifiers, ex 'username@appname.accname'
                */
            unsubscribe(users: Array<string>): void;
            /**
                * @hidden
                * @deprecated
                * @param status
                */
            setPresence(status: boolean): void;
            /**
                * Set user presence status.
                * Triggers the [MessengerEvents.SetStatus] event for all messenger objects on all *connected* clients which are subscribed for notifications about this user. Including this one if conditions are met.
                * @see [MessengerEvents.SetStatus]
                * @see [MessengerEvents.Error]
                * @param status true if user is available for messaging.
                */
            setStatus(status: boolean): void;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
    }
}

declare module 'voximplant-websdk/Messenger/src/Structures' {
    import { MsgAction, MsgEvent, MsgService } from 'voximplant-websdk/Signaling/MsgEnums';
    import { Conversation } from 'voximplant-websdk/Messenger/src/Conversation';
    import { Message } from 'voximplant-websdk/Messenger/src/Message';
    import Messaging from 'voximplant-websdk/Messenger/index';
    /**
        * @hidden
        */
    export interface Payload {
            /**
                * Payload fragment unique title. Used to identifier fragment in the list of fragments associated with the message.
                */
            title: string;
            /**
                * Arbitrary payload type string.
                */
            type: string;
            /**
                *  JavaScript object payload data.
                */
            data: Object;
    }
    /**
        * @hidden
        */
    export interface User {
            /**
                * Full Voximplant user identifier, ex 'username@appname.accname'
                */
            userId: string;
            /**
                * Public JavaScript object custom data, available to all users
                */
            customData: Object;
            /**
                * List of UUIDs for the conversations the user is joined. Only available if user queries information about themselves.
                */
            conversationsList?: Array<string>;
            /**
                * Private JavaScript object custom data, available only to the user themselve.
                */
            privateCustomData?: Object;
            /**
                * @hidden
                */
            leaveConversationList: Array<string>;
    }
    /**
        * @hidden
        */
    export interface ConversationParticipant {
            /**
                * Full Voximplant user identifier, ex 'username@appname.accname'
                */
            userId: string;
            /**
                * If 'true', user can write to the conversation
                */
            canWrite: boolean;
            /**
                * If 'true', user can add, remove and edit access rights for conversation participants (but not conversation moderators).
                */
            canManageParticipants: boolean;
    }
    /**
        * @hidden
        */
    export interface UserStatus {
            /**
                * Full Voximplant user identifier, ex 'username@appname.accname'
                */
            userId: string;
            /**
                * True if user is online (set by the 'setStatus' call).
                */
            online: boolean;
            /**
                * UNIX timestamp integer that specifies the time event was triggered. It's same as 'Date.now()' divided by 1000.
                */
            timestamp: number;
    }
    /**
        * @hidden
        */
    export interface SerializedConversation {
            seq: number;
            lastUpdate: number;
            uuid: string;
            title: string;
            moderators: Array<string>;
            createdAt: string;
            lastRead: number;
            distinct: boolean;
            publicJoin: boolean;
            participants: Array<ConversationParticipant>;
            customData: any;
            uberConversation: boolean;
    }
    /**
        * @hidden
        */
    export interface SerializedMessage {
            seq: number;
            uuid: string;
            text: string;
            payload: Array<Payload>;
            conversation: string;
            sender: string;
    }
    /**
        * @hidden
        */
    export interface BusPayload {
            object: MsgMessage | MsgConversation | MsgUser | MsgRead | Array<MsgBusMessage>;
            user_id: string;
            seq: number;
            on_incoming_event: string;
    }
    /**
        * @hidden
        */
    export interface MsgRead {
            conversation: string;
            timestamp: number;
            seq: number;
    }
    /**
        * Created by irbisadm on 22/09/16.
        * @hidden
        */
    export interface MsgBusMessage {
            service: MsgService;
            event: MsgAction | MsgEvent;
            payload: BusPayload;
    }
    /**
        * @hidden
        */
    export interface MsgConversation {
            uuid: string;
            moderators?: Array<string>;
            created_at?: string;
            last_update?: string;
            title: string;
            last_read?: number;
            distinct?: boolean;
            enable_public_join?: boolean;
            participants: Array<MsgParticipant>;
            custom_data?: any;
            uber_conversation?: boolean;
    }
    /**
        * @hidden
        */
    export interface MsgParticipant {
            user_id: string;
            can_write: boolean;
            can_manage_participants: boolean;
    }
    /**
        * @hidden
        */
    export interface MsgMessage {
            uuid: string;
            sender?: string;
            text: string;
            conversation: string;
            payload?: Array<MsgPayload>;
    }
    /**
        * @hidden
        */
    export interface MsgPayload {
            title: string;
            type: string;
            data: any;
    }
    /**
        * @hidden
        */
    export interface MsgUser {
            user_id: string;
            custom_data: any;
            private_custom_data?: any;
            conversations_list: Array<string>;
            leave_conversation_list: Array<string>;
    }
    /**
        * @hidden
        */
    export interface RetransmittedEvent {
            /**
                * Event name
                */
            name: string;
            /**
                * Conversation object
                */
            conversation?: Conversation;
            /**
                * Message object
                */
            message?: Message;
            /**
                * Full Voximplant user identifier, ex 'username@appname.accname', for the user that initiated the event.
                */
            userId: string;
            /**
                * Sequence number for this event
                */
            seq: number;
            /**
                * Enum of the action that is the reason this event was triggered
                */
            onIncomingEvent: Messaging.MessengerAction;
    }
}

declare module 'voximplant-websdk/Hardware/src/AudioDeviceManager' {
    import { Call } from 'voximplant-websdk/Call/Call';
    import { AudioOutputInfo, AudioSourceInfo } from 'voximplant-websdk/Structures';
    import { AudioParams } from 'voximplant-websdk/Hardware/src/AudioParams';
    /**
        * @hidden
        */
    export class AudioDeviceManager {
            /**
                * @hidden
                */
            constructor();
            /**
                * @hidden
                */
            getAudioContext(): any;
            /**
                * Create an AudioContext object inside SDK. This function must be used on a user gesture at Google Chrome 66 and above
                * See <a href="https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio"> Google Developers Blog post</a> about this issue
                */
            prepareAudioContext(): void;
            /**
                * Get the AudioDeviceManager instance
                */
            static get(): AudioDeviceManager;
            /**
                * Return available audio input devices (sound card/processor). Note that if new passive microphone was plugged into the same sound card, the method will return that sound card; if new microphone has its own sound processor, the method will return the updated array with new device.
                */
            getInputDevices(): Promise<Array<AudioSourceInfo>>;
            /**
                * Return available audio output devices (sound card/processor). If new plugged device has its own sound processor, the method will return the updated array with new device.
                */
            getOutputDevices(): Promise<Array<AudioOutputInfo>>;
            /**
                * Return default audio settings as the [AudioParams] object.
                */
            getDefaultAudioSettings(): AudioParams;
            /**
                * Set default audio settings for calls.
                */
            setDefaultAudioSettings(params: AudioParams): void;
            /**
                * Set audio settings for specified call.
                */
            setCallAudioSettings(call: Call, params: AudioParams): Promise<void>;
            /**
                * Return audio settings of specified call as the [AudioParams] object.
                */
            getCallAudioSettings(call: Call): AudioParams;
            /**
                * @hidden
                */
            getCallConstraints(callID: string): Object;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
    }
}

declare module 'voximplant-websdk/Hardware/src/AudioParams' {
    /**
        *
        */
    export interface AudioParams {
            /**
                * Unique ID of microphone. It can be received via the [AudioDeviceManager.getInputDevices] method.
                */
            inputId?: string;
            /**
                * Unique ID of a sound card/processor. It can be received via the [AudioDeviceManager.getOutputDevices] method.
                */
            outputId?: string;
            /**
                * Should participant's echo be cancelled or not? If it's true, echo is cancelled; it's *true* by default.
                */
            echoCancellation?: boolean;
            /**
                * If this value is a true or false, the user agent will attempt to obtain media with automatic gain control enabled or disabled as specified, if possible.
                */
            autoGainControl?: boolean;
            /**
                * If it's true, backgroung noise is suppressed. It's *true* by default.
                */
            noiseSuppression?: boolean;
            /**
                * If it's true, all audio settings must suit each other strictly; the incorrect settings will cause an error. If it's false, the incorrect values will be changed to the best appropriate values. It's *false* by default.
                */
            strict?: boolean;
            /**
                * @hidden
                */
            disableAudio?: boolean;
    }
}

declare module 'voximplant-websdk/Hardware/src/CameraManager' {
    import { CameraParams } from 'voximplant-websdk/Hardware/src/CameraParams';
    import { VideoSourceInfo } from 'voximplant-websdk/Structures';
    import { Call } from 'voximplant-websdk/Call/Call';
    /**
        * @hidden
        */
    export class CameraManager {
            /**
                * @hidden
                */
            constructor();
            /**
                * Get the CameraManager instance
                */
            static get(): CameraManager;
            /**
                * Set default video settings for calls.
                */
            setDefaultVideoSettings(params: CameraParams): Promise<void>;
            /**
                * Return default audio settings as the [CameraParams] object.
                */
            getDefaultVideoSettings(): CameraParams;
            /**
                * Set video settings for specified call.
                */
            setCallVideoSettings(call: Call, params: CameraParams): Promise<void>;
            /**
                * Return video settings of specified call as the [CameraParams] object.
                */
            getCallVideoSettings(call: Call): CameraParams;
            /**
                * @hidden
                */
            getCallConstraints(callID: string): Object;
            /**
                * Return available video input devices (web camera(s)).
                */
            getInputDevices(): Promise<Array<VideoSourceInfo>>;
            /**
                * @hidden
                */
            static legacyParamConverter(videoParams: any): CameraParams;
            /**
                * Start camera resolution test for each video source in system.</br>
                * *Attention!* This procedure may take a lot of time and will send multiple Camera requests for
                * the Mozilla Firefox and Apple Safari browsers!</br>
                * Please, don't run it without warning user's request and attention.</br>
                * After running this function, please, save result to a browser storage (like LocalStorage or IndexedDB) and use it
                * in future with the [loadResolutionTestResult] function to restore
                * results.
                * This function mandatory only if you will use Hardware.VideoQuality.VIDEO_QUALITY_HIGH,Hardware.VideoQuality.VIDEO_QUALITY_MEDIUM or
                * Hardware.VideoQuality.VIDEO_QUALITY_LOW enums as video settings and strongly not recommended to use in another case.
                * @returns {Promise<any>}
                */
            testResolutions(cameraId?: string): Promise<any>;
            /**
                * Restoring a camera resolution test result previously got by [testResolutions]
                * function.
                * @returns {Promise<void>}
                */
            loadResolutionTestResult(data: any): boolean;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
    }
}

declare module 'voximplant-websdk/Hardware/src/CameraParams' {
    import Hardware from 'voximplant-websdk/Hardware';
    /**
        * @hidden
        */
    export interface CameraParams {
            /**
                * Unique ID of camera. It can be received via the [CameraManager.getInputDevices] method.
                */
            cameraId?: string;
            /**
                * One of the <a href="//voximplant.com/docs/references/websdk/enums/hardware.videoquality.html">video quality</a> values. The parameter is prior than <a href="#framewidth">frameWidth</a> and <a href="#frameheight">frameHeight</a> parameters.
                */
            videoQuality?: Hardware.VideoQuality;
            /**
                * Flip image or not? If it's true, the image will be flipped (mirror mode). It's *false* by default.
                */
            facingMode?: boolean;
            /**
                * Width of a frame in pixels. The parameter is less prior than <a href="#videoquality">videoQuality</a>.
                */
            frameWidth?: number;
            /**
                * Height of a frame in pixels. The parameter is less prior than <a href="#videoquality">videoQuality</a>.
                */
            frameHeight?: number;
            /**
                * If it's true, all video settings must suit each other strictly; the incorrect settings will cause an error. If it's false, the incorrect values will be changed to the best appropriate values. It's *false* by default.
                */
            strict?: boolean;
            /**
                * Frames per second.
                */
            frameRate?: number;
    }
}

declare module 'voximplant-websdk/Hardware/src/SharingStream' {
    import { MediaRenderer } from 'voximplant-websdk/Media/MediaRenderer';
    /**
      * @hidden
      */
    export interface SharingStream {
        renderer?: MediaRenderer;
        stream: MediaStream;
    }
}

declare module 'voximplant-websdk/Hardware/src/StreamManager' {
    import Hardware from 'voximplant-websdk/Hardware';
    import { EventTarget } from 'voximplant-websdk/EventTarget';
    import { Call } from 'voximplant-websdk/Call/Call';
    import { EventHandlers } from 'voximplant-websdk/EventHandlers';
    import Updated = EventHandlers.Updated;
    import { MediaRenderer } from 'voximplant-websdk/Media/MediaRenderer';
    import { SharingStream } from 'voximplant-websdk/Hardware/src/SharingStream';
    import { TrackType } from 'voximplant-websdk/Types';
    /**
        * @hidden
        */
    export class StreamManager extends EventTarget<Hardware.HardwareEvents> {
            /**
                * @hidden
                */
            constructor();
            /**
                * Get the StreamManager instance
                */
            static get(): StreamManager;
            /**
                * Return link to the mirror stream, if exist. Or get a new one.
                * @hidden
                * @return {Promise<MediaStream>}
                */
            getMirrorStream(): Promise<MediaStream>;
            /**
                * @hidden
                */
            remMirrorStream(): void;
            /**
                * @hidden
                * @param {Call} call
                * @returns {Promise<MediaStream>}
                */
            getCallStream(call: Call, ignore?: boolean): Promise<MediaStream>;
            /**
                * @hidden
                * @param {Call} call
                * @returns {Promise<MediaStream>}
                * @private
                */
            _updateCallStream(call: Call): Promise<MediaStream>;
            /**
                * @hidden
                * @param {Call} call
                * @returns {Promise<EventHandlers.Updated>}
                */
            updateCallStream(call: Call): Promise<Updated>;
            /**
                * @hidden
                * @param {Call} call
                */
            remCallStream(call: Call): void;
            /**
                * @hidden
                * @param {Call} call
                */
            _remCallStream(stream: MediaStream): void;
            /**
                * @hidden
                */
            clear(): void;
            /**
                * List of currently used containers for local audio and video streams.
                */
            getLocalMediaRenderers(): MediaRenderer[];
            /**
                * Turn on local video. The container for local video elements must be specified via in the
                * [Config.localVideoContainerId] field in the [Client.init] config.
                *   If it's not specified, local videos will be appended to end of the *<body>* element.
                *  Use the <a href="#hidelocalvideo">hideLocalVideo</a> method to turn off local video.
                */
            showLocalVideo(): Promise<MediaRenderer>;
            /**
                * Turn off local video. Use the <a href="#showlocalvideo">showLocalVideo</a> method to turn on local video.
                */
            hideLocalVideo(): Promise<void>;
            /**
                * Register a handler for the specified event. The method is a shorter equivalent for *addEventListener*. One event can have more than one handler; handlers are executed in order of registration.
                * Use the [StreamManager.off] method to delete a handler.
                */
            on(event: Hardware.HardwareEvents, handler: Function): void;
            /**
                * Remove a handler for the specified event. The method is a shorter equivalent for *removeEventListener*. If a number of events has the same function as a handler, the method can be called multiple times with the same handler argument.
                */
            off(event: Hardware.HardwareEvents, handler?: Function): void;
            /**
                * Get sharing media and create renderer if need.
                * @hidden
                * @param {Call} call
                * @param {boolean} showLocalVideo
                * @returns {Promise<Hardware.SharingStream>}
                */
            _newScreenSharing(call: Call, showLocalVideo: boolean): Promise<SharingStream>;
            /**
                * @hidden
                * @param {Call} call
                * @returns {Hardware.SharingStream[]}
                * @private
                */
            _getScreenSharing(call: Call): SharingStream[];
            /**
                * @hidden
                * @param {Call} call
                * @param {SharingStream} sharingStream
                * @returns {Promise<void>}
                * @private
                */
            _clearScreenSharing(call: Call, sharingStream: SharingStream): Promise<void>;
            /**
                * @hidden
                * @param {Call} call
                * @returns {{[p: string]: TrackType}}
                * @private
                */
            _getTracksKind(call: Call): {
                    [id: string]: TrackType;
            };
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
    }
}

declare module 'voximplant-websdk/Hardware/src/IOSCacheManager' {
    import { Call } from 'voximplant-websdk/Call/Call';
    import { MediaRenderer } from 'voximplant-websdk/Media/MediaRenderer';
    export class IOSCacheManager {
            static get(): IOSCacheManager;
            constructor();
            getStream(constrains: {
                    [id: string]: any;
            }): Promise<MediaStream>;
            clear(call: Call): void;
            registerMediaRenderer(call: Call, mediaRenderer: MediaRenderer): void;
    }
}

declare module 'voximplant-websdk/PeerConnection/ReInviteQ' {
    /**
        * @hidden
        */
    import { Call } from "voximplant-websdk/Call/Call";
    /**
        * @hidden
        */
    export class ReInviteQ {
            constructor(call: Call, _pcStatus: {
                    (): boolean;
            });
            runNext(): void;
            add(member: ReIviteQMember): void;
            clear(): void;
            /**
                * @hidden
                * @return {string}
                * @private
                */
            _traceName(): string;
    }
    /**
        * @hidden
        */
    export interface ReIviteQMember {
            resolve: Function;
            reject: Function;
            fx: Function;
    }
}

declare module 'voximplant-websdk/Signaling/MsgEnums' {
    /**
        * @hidden
        */
    export enum MsgService {
            Chat
    }
    /**
        * @hidden
        */
    export enum MsgAction {
            createConversation,
            editConversation,
            removeConversation,
            joinConversation,
            leaveConversation,
            getConversation,
            getConversations,
            sendMessage,
            editMessage,
            removeMessage,
            typingMessage,
            editUser,
            getUser,
            getUsers,
            retransmitEvents,
            isRead,
            isDelivered,
            addParticipants,
            editParticipants,
            removeParticipants,
            addModerators,
            removeModerators,
            subscribe,
            unsubscribe,
            setStatus
    }
    /**
        * @hidden
        */
    export enum MsgEvent {
            onCreateConversation,
            onEditConversation,
            onRemoveConversation,
            onJoinConversation,
            onLeaveConversation,
            onGetConversation,
            onSendMessage,
            onEditMessage,
            onRemoveMessage,
            onTyping,
            onRetransmitEvents,
            onEditUser,
            onGetUser,
            onError,
            isRead,
            isDelivered,
            onsubscribe,
            onUnSubscribe,
            onSetStatus
    }
}

declare module 'voximplant-websdk/Hardware' {
    import * as Implement from 'voximplant-websdk/Hardware/src';
    export module Hardware {
            /**
                * Events that are triggered when hardware device is added/removed/updated.
                */
            enum HardwareEvents {
                    /**
                        * Event is triggered each time when device is added/removed. Devices that trigger the event: microphones, video camera and sound output (available only in Google Chrome).
                        */
                    DevicesUpdated,
                    /**
                        * Event is triggered when local video or audio is started. E.g. when local video or screen sharing is stared.
                        */
                    MediaRendererAdded,
                    /**
                        * Event is triggered when local video or audio streaming is stopped. E.g. when local video or screen sharing streaming is stopped.
                        */
                    MediaRendererRemoved,
                    /**
                        * Event is triggered before local video or audio streaming is stopped. E.g. before local video or screen sharing streaming is stopped.
                        */
                    BeforeMediaRendererRemoved
            }
            /**
                * Enum that represents video quality.
                */
            enum VideoQuality {
                    /**
                        * Set better video quality for the current web camera.
                        * This option uses the last value from the [CameraManager.testResolutions] function result,
                        * or the data set to the [CameraManager.loadResolutionTestResult].
                        * If there is no result for a target web camera, use 1280x720 resolution
                        */
                    VIDEO_QUALITY_HIGH,
                    /**
                        * Set medium video quality for the current web camera.
                        * This option uses the last value from the [CameraManager.testResolutions] function result,
                        * or the data set to the [CameraManager.loadResolutionTestResult].
                        * If there is no result for a target web camera, use 640x480 resolution
                        */
                    VIDEO_QUALITY_LOW,
                    /**
                        * Set lower video quality for the current web camera.
                        * This option uses the last value from the [CameraManager.testResolutions] function result,
                        * or the data set to the [CameraManager.loadResolutionTestResult].
                        * If there is no result for a target web camera, use 320x240 resolution
                        */
                    VIDEO_QUALITY_MEDIUM,
                    /**
                        * 160x120 resolution
                        */
                    VIDEO_SIZE_QQVGA,
                    /**
                        * 176x144 resolution
                        */
                    VIDEO_SIZE_QCIF,
                    /**
                        * 320x240 resolution
                        */
                    VIDEO_SIZE_QVGA,
                    /**
                        * 352x288 resolution
                        */
                    VIDEO_SIZE_CIF,
                    /**
                        * 640x360 resolution
                        */
                    VIDEO_SIZE_nHD,
                    /**
                        * 640x480 resolution
                        */
                    VIDEO_SIZE_VGA,
                    /**
                        * 800x600 resolution
                        */
                    VIDEO_SIZE_SVGA,
                    /**
                        * 1280x720 resolution
                        */
                    VIDEO_SIZE_HD,
                    /**
                        * 1600x1200 resolution
                        */
                    VIDEO_SIZE_UXGA,
                    /**
                        * 1920x1080 resolution
                        */
                    VIDEO_SIZE_FHD,
                    /**
                        * 3840x2160 resolution
                        */
                    VIDEO_SIZE_UHD
            }
            /**
                * Interface that may be used to manage audio devices, i.e. see current active device, select another active device and get the list of available devices.
                */
            class AudioDeviceManager extends Implement.AudioDeviceManager {
            }
            /**
                * Audio constraints. Audio device will be chosen according to these settings.</br>
                * Settings are specified via
                * [AudioDeviceManager.setDefaultAudioSettings]
                *   and
                *   [AudioDeviceManager.setCallAudioSettings].
                */
            interface AudioParams extends Implement.AudioParams {
            }
            /**
                * Interface that may be used to manage cameras on Android device.
                */
            class CameraManager extends Implement.CameraManager {
            }
            /**
                * Camera constraints. Hardware camera will be chosen according to these settings.</br>
                * Settings are specified via
                * [CameraManager.setDefaultVideoSettings]
                *   and [CameraManager.setCallVideoSettings].
                */
            interface CameraParams extends Implement.CameraParams {
            }
            /**
                * @hidden
                */
            interface SharingStream extends Implement.SharingStream {
            }
            /**
                * Interface for extended management of local audio/video streams.
                */
            class StreamManager extends Implement.StreamManager {
            }
            /**
                * @hidden
                */
            class IOSCacheManager extends Implement.IOSCacheManager {
            }
    }
    export default Hardware;
}

